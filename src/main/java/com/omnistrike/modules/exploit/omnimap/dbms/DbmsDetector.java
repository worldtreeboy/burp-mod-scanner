package com.omnistrike.modules.exploit.omnimap.dbms;

import java.util.LinkedHashMap;
import java.util.Map;
import java.util.regex.Pattern;

/**
 * Auto-detects the backend DBMS from error messages and behavioral fingerprints.
 * Returns the best-matching DbmsDialect or defaults to MySQL.
 */
public class DbmsDetector {

    private static final Map<String, DbmsDialect> DIALECTS = new LinkedHashMap<>();

    static {
        DIALECTS.put("MySQL", new MysqlDialect());
        DIALECTS.put("PostgreSQL", new PostgresDialect());
        DIALECTS.put("MSSQL", new MssqlDialect());
        DIALECTS.put("Oracle", new OracleDialect());
        DIALECTS.put("SQLite", new SqliteDialect());
    }

    /**
     * Detect DBMS from an HTTP response body by matching error patterns.
     * Returns the dialect with the highest match count, or null if no matches.
     */
    public static DbmsDialect detectFromResponse(String responseBody) {
        if (responseBody == null || responseBody.isEmpty()) return null;

        DbmsDialect bestMatch = null;
        int bestScore = 0;

        for (DbmsDialect dialect : DIALECTS.values()) {
            int score = 0;
            for (Pattern pattern : dialect.errorPatterns()) {
                if (pattern.matcher(responseBody).find()) {
                    score++;
                }
            }
            if (score > bestScore) {
                bestScore = score;
                bestMatch = dialect;
            }
        }

        return bestScore > 0 ? bestMatch : null;
    }

    /**
     * Get a dialect by explicit DBMS name.
     * Case-insensitive matching, falls back to MySQL.
     */
    public static DbmsDialect getDialect(String dbmsName) {
        if (dbmsName == null) return new MysqlDialect();

        for (Map.Entry<String, DbmsDialect> entry : DIALECTS.entrySet()) {
            if (entry.getKey().equalsIgnoreCase(dbmsName)) {
                return entry.getValue();
            }
        }

        // Fuzzy matching
        String lower = dbmsName.toLowerCase();
        if (lower.contains("mysql") || lower.contains("maria")) return new MysqlDialect();
        if (lower.contains("postgre") || lower.contains("pgsql")) return new PostgresDialect();
        if (lower.contains("mssql") || lower.contains("microsoft") || lower.contains("sqlserver")) return new MssqlDialect();
        if (lower.contains("oracle")) return new OracleDialect();
        if (lower.contains("sqlite")) return new SqliteDialect();

        return new MysqlDialect(); // default
    }

    /** Returns all available dialect names */
    public static String[] getAvailableDbms() {
        return DIALECTS.keySet().toArray(new String[0]);
    }

    /** Returns all available dialects */
    public static Map<String, DbmsDialect> getAllDialects() {
        return new LinkedHashMap<>(DIALECTS);
    }
}
