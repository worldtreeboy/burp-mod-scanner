package com.omnistrike.modules.exploit.omnimap.technique;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Response comparison engine for OmniMap blind extraction.
 * Closely mirrors sqlmap's comparison logic (difflib.SequenceMatcher + dynamic removal).
 *
 * How sqlmap compares responses:
 * 1. Send the same request multiple times to build a "dynamic content" mask
 * 2. Strip dynamic regions (parts that change between identical requests)
 * 3. Compare using SequenceMatcher ratio (LCS-based)
 * 4. Also check: status code, content-length, redirect URL, title tag
 *
 * OmniMap improvements:
 * - Fingerprint caching (skip re-parsing identical bodies)
 * - Sample-based comparison for large responses (>10KB)
 * - Content-length shortcut before full body diff
 */
public class ResponseAnalyzer {

    /** Cached response fingerprints: hash(body) → fingerprint */
    private final Map<Integer, ResponseFingerprint> fingerprintCache = new ConcurrentHashMap<>();

    /** Configurable similarity threshold (0.0 - 1.0) */
    private double similarityThreshold = 0.90;

    /** Custom true/false match strings (like sqlmap --string / --not-string) */
    private String trueString = "";
    private String falseString = "";

    /** Dynamic content regions identified from baseline comparison */
    private final List<DynamicRegion> dynamicRegions = new ArrayList<>();

    /** Baseline HTTP status codes for true/false */
    private int trueStatusCode = -1;
    private int falseStatusCode = -1;

    public void setTrueString(String s) { this.trueString = s != null ? s : ""; }
    public void setFalseString(String s) { this.falseString = s != null ? s : ""; }
    public void setSimilarityThreshold(double t) { this.similarityThreshold = t; }
    public void setTrueStatusCode(int code) { this.trueStatusCode = code; }
    public void setFalseStatusCode(int code) { this.falseStatusCode = code; }
    public int getTrueStatusCode() { return this.trueStatusCode; }
    public int getFalseStatusCode() { return this.falseStatusCode; }

    /**
     * Calibrate dynamic content by comparing two identical responses.
     * Like sqlmap's checkDynParam() — finds regions that change between identical requests
     * so they can be masked during true/false comparison.
     */
    public void calibrateDynamic(String response1, String response2) {
        if (response1 == null || response2 == null) return;
        dynamicRegions.clear();

        int len1 = response1.length();
        int len2 = response2.length();
        int minLen = Math.min(len1, len2);

        // Find regions where the two identical responses differ
        int i = 0;
        while (i < minLen) {
            if (response1.charAt(i) != response2.charAt(i)) {
                int start = i;
                // Find end of differing region
                while (i < minLen && response1.charAt(i) != response2.charAt(i)) {
                    i++;
                }
                // Expand to word boundaries
                int regionStart = Math.max(0, start - 5);
                int regionEnd = Math.min(minLen, i + 5);
                dynamicRegions.add(new DynamicRegion(regionStart, regionEnd - regionStart));
            }
            i++;
        }
    }

    /**
     * Determines if a response matches the "true" condition.
     * Uses multiple signals like sqlmap: string match → status code → content-length → body ratio.
     *
     * @param trueBaseline  response body when condition is true
     * @param falseBaseline response body when condition is false
     * @param candidate     response body to classify
     * @return true if candidate matches the true baseline
     */
    public boolean isTruePage(String trueBaseline, String falseBaseline, String candidate) {
        if (candidate == null) return false;

        // Priority 1: Custom string match (like sqlmap --string / --not-string)
        if (!trueString.isEmpty()) {
            return candidate.contains(trueString);
        }
        if (!falseString.isEmpty()) {
            return !candidate.contains(falseString);
        }

        if (trueBaseline == null) return false;

        // Priority 2: Content-length comparison (fast path)
        int candLen = candidate.length();
        int trueLen = trueBaseline.length();
        int falseLen = falseBaseline != null ? falseBaseline.length() : 0;

        if (falseBaseline != null && Math.abs(trueLen - falseLen) > 50) {
            int trueDiff = Math.abs(candLen - trueLen);
            int falseDiff = Math.abs(candLen - falseLen);
            if (trueDiff < 20 && falseDiff > 50) return true;
            if (falseDiff < 20 && trueDiff > 50) return false;
        }

        // Priority 3: Title tag comparison (like sqlmap)
        String candTitle = extractTitle(candidate);
        String trueTitle = extractTitle(trueBaseline);
        String falseTitle = falseBaseline != null ? extractTitle(falseBaseline) : null;

        if (candTitle != null && trueTitle != null && falseTitle != null
                && !trueTitle.equals(falseTitle)) {
            if (candTitle.equals(trueTitle)) return true;
            if (candTitle.equals(falseTitle)) return false;
        }

        // Priority 4: Full body similarity ratio (like sqlmap's difflib.SequenceMatcher)
        double trueRatio = similarity(trueBaseline, candidate);
        if (falseBaseline != null) {
            double falseRatio = similarity(falseBaseline, candidate);
            return trueRatio > falseRatio;
        }

        return trueRatio > similarityThreshold;
    }

    /**
     * Extended true/false check that also considers HTTP status codes.
     * Use this when you have status code information.
     */
    public boolean isTruePage(String trueBaseline, String falseBaseline, String candidate,
                               int candidateStatus) {
        // Status code difference is a strong signal (like sqlmap)
        if (trueStatusCode > 0 && falseStatusCode > 0 && trueStatusCode != falseStatusCode) {
            if (candidateStatus == trueStatusCode) return true;
            if (candidateStatus == falseStatusCode) return false;
        }

        return isTruePage(trueBaseline, falseBaseline, candidate);
    }

    /**
     * Checks if a response time indicates a time-based delay.
     * Uses statistical validation: response must exceed threshold + jitter margin.
     */
    public boolean isTimeBased(long responseTimeMs, int expectedDelaySeconds) {
        long thresholdMs = (long) (expectedDelaySeconds * 1000 * 0.75); // 75% of expected delay
        return responseTimeMs >= thresholdMs;
    }

    /**
     * Extract data from error messages using regex patterns.
     */
    public String extractErrorData(String responseBody, List<Pattern> patterns) {
        if (responseBody == null) return null;
        for (Pattern pattern : patterns) {
            Matcher m = pattern.matcher(responseBody);
            if (m.find()) {
                return m.groupCount() > 0 ? m.group(1) : m.group();
            }
        }
        return null;
    }

    /**
     * Locate a UNION marker in the response body.
     */
    public String findUnionMarker(String responseBody, String startMarker, String endMarker) {
        if (responseBody == null || startMarker == null) return null;
        int start = responseBody.indexOf(startMarker);
        if (start < 0) return null;
        start += startMarker.length();

        if (endMarker != null) {
            int end = responseBody.indexOf(endMarker, start);
            if (end < 0) return null;
            return responseBody.substring(start, end);
        }

        int end = start;
        while (end < responseBody.length()) {
            char c = responseBody.charAt(end);
            if (c == '<' || c == '\n' || c == '\r') break;
            end++;
        }
        return responseBody.substring(start, end).trim();
    }

    /**
     * Compute similarity ratio between two strings.
     * Port of Python's difflib.SequenceMatcher.ratio() — the same algorithm sqlmap uses.
     * Formula: 2.0 * M / T where M = total matched characters across all contiguous
     * matching blocks, T = total characters in both strings.
     *
     * This is NOT LCS (longest common subsequence). SequenceMatcher finds the longest
     * contiguous matching block, then recursively finds matching blocks in the remaining
     * left and right portions. This gives a lower (more accurate) ratio than LCS because
     * it requires contiguity — matching sqlmap's actual comparison behavior.
     */
    public double similarity(String a, String b) {
        if (a == null || b == null) return 0.0;
        if (a.equals(b)) return 1.0;
        if (a.isEmpty() || b.isEmpty()) return 0.0;

        // Strip dynamic content (timestamps, tokens, nonces + calibrated regions)
        a = stripDynamic(a);
        b = stripDynamic(b);

        if (a.equals(b)) return 1.0;

        int lenA = a.length();
        int lenB = b.length();

        // Quick length-ratio check (sqlmap also does this)
        double lengthRatio = (double) Math.min(lenA, lenB) / Math.max(lenA, lenB);
        if (lengthRatio < 0.5) return lengthRatio;

        // For very large bodies, sample blocks instead of full comparison
        if (lenA > 10000 || lenB > 10000) {
            return sampleSimilarity(a, b);
        }

        // SequenceMatcher matching-blocks ratio
        int matched = matchingBlocksTotal(a, b, 0, lenA, 0, lenB);
        return (2.0 * matched) / (lenA + lenB);
    }

    /**
     * Sample-based similarity for large responses.
     * Compares start, middle, and end blocks.
     */
    private double sampleSimilarity(String a, String b) {
        int blockSize = 2000;
        double total = 0;
        int count = 0;

        // Start block
        String aStart = a.substring(0, Math.min(blockSize, a.length()));
        String bStart = b.substring(0, Math.min(blockSize, b.length()));
        total += blockSimilarity(aStart, bStart);
        count++;

        // Middle block
        int aMid = Math.max(0, a.length() / 2 - blockSize / 2);
        int bMid = Math.max(0, b.length() / 2 - blockSize / 2);
        total += blockSimilarity(
                a.substring(aMid, Math.min(aMid + blockSize, a.length())),
                b.substring(bMid, Math.min(bMid + blockSize, b.length())));
        count++;

        // End block
        int aEnd = Math.max(0, a.length() - blockSize);
        int bEnd = Math.max(0, b.length() - blockSize);
        total += blockSimilarity(a.substring(aEnd), b.substring(bEnd));
        count++;

        return total / count;
    }

    private double blockSimilarity(String a, String b) {
        if (a.equals(b)) return 1.0;
        int matched = matchingBlocksTotal(a, b, 0, a.length(), 0, b.length());
        return (2.0 * matched) / (a.length() + b.length());
    }

    /**
     * Port of Python's difflib.SequenceMatcher.get_matching_blocks().
     * Recursively finds the longest contiguous matching block between
     * a[aLo..aHi) and b[bLo..bHi), then recurses on the left and right
     * portions. Returns the total number of matched characters.
     *
     * This matches sqlmap's actual comparison: contiguous block matching,
     * not LCS (non-contiguous subsequence).
     */
    private int matchingBlocksTotal(String a, String b, int aLo, int aHi, int bLo, int bHi) {
        // Find the longest contiguous matching block in a[aLo..aHi) and b[bLo..bHi)
        int bestI = aLo, bestJ = bLo, bestSize = 0;

        // j2len[j] = length of longest match ending at a[i-1] and b[j-1]
        // We only need the current row, similar to SequenceMatcher's approach
        Map<Integer, Integer> j2len = new HashMap<>();

        for (int i = aLo; i < aHi; i++) {
            Map<Integer, Integer> newJ2len = new HashMap<>();
            for (int j = bLo; j < bHi; j++) {
                if (a.charAt(i) == b.charAt(j)) {
                    int k = j2len.getOrDefault(j - 1, 0) + 1;
                    newJ2len.put(j, k);
                    if (k > bestSize) {
                        bestI = i - k + 1;
                        bestJ = j - k + 1;
                        bestSize = k;
                    }
                }
            }
            j2len = newJ2len;
        }

        if (bestSize == 0) return 0;

        // Recurse on left portion (before the match) and right portion (after the match)
        int leftMatched = (aLo < bestI && bLo < bestJ)
                ? matchingBlocksTotal(a, b, aLo, bestI, bLo, bestJ) : 0;
        int rightMatched = (bestI + bestSize < aHi && bestJ + bestSize < bHi)
                ? matchingBlocksTotal(a, b, bestI + bestSize, aHi, bestJ + bestSize, bHi) : 0;

        return leftMatched + bestSize + rightMatched;
    }

    /**
     * Strip dynamic content that changes between identical requests.
     * Combines regex-based patterns + calibrated dynamic regions.
     */
    private static final Pattern DYNAMIC_PATTERNS = Pattern.compile(
            "(?:" +
            "\\b\\d{10,13}\\b" +                    // Unix timestamps (10-13 digits)
            "|\\b[0-9a-f]{32,64}\\b" +              // Hex tokens/hashes (32-64 chars)
            "|nonce=\"[^\"]*\"" +                    // CSP nonces
            "|csrf[^=]*=[^&\"'\\s]*" +              // CSRF tokens in any context
            "|_=\\d+" +                              // jQuery cache-busting
            "|\\btoken=[^&\"'\\s]*" +                // Generic token params
            "|\\bsid=[^&\"'\\s]*" +                  // Session IDs
            "|\\bviewstate[^=]*=[^&\"'\\s]*" +       // ASP.NET ViewState
            ")", Pattern.CASE_INSENSITIVE);

    private String stripDynamic(String s) {
        String result = DYNAMIC_PATTERNS.matcher(s).replaceAll("");

        // Also mask calibrated dynamic regions
        if (!dynamicRegions.isEmpty() && result.length() > 0) {
            StringBuilder sb = new StringBuilder(result);
            for (DynamicRegion region : dynamicRegions) {
                int start = Math.min(region.offset, sb.length());
                int end = Math.min(region.offset + region.length, sb.length());
                if (start < end) {
                    for (int i = start; i < end; i++) {
                        sb.setCharAt(i, ' ');
                    }
                }
            }
            result = sb.toString();
        }

        return result;
    }

    /**
     * Extract the <title> tag content from HTML.
     * sqlmap uses title comparison as a quick true/false signal.
     */
    private static final Pattern TITLE_PATTERN =
            Pattern.compile("<title[^>]*>([^<]*)</title>", Pattern.CASE_INSENSITIVE);

    private static String extractTitle(String html) {
        if (html == null) return null;
        Matcher m = TITLE_PATTERN.matcher(html);
        return m.find() ? m.group(1).trim() : null;
    }

    /** Get or create a fingerprint for a response body. */
    public ResponseFingerprint fingerprint(String body) {
        if (body == null) return new ResponseFingerprint(0, 0, "");
        int hash = body.hashCode();
        return fingerprintCache.computeIfAbsent(hash,
                k -> new ResponseFingerprint(body.length(), body.lines().count(), stripDynamic(body)));
    }

    /** Clear the fingerprint cache */
    public void clearCache() {
        fingerprintCache.clear();
    }

    // ==================== Auto-Detection of True/False Strings ====================

    /**
     * Auto-detect a string that uniquely identifies "true" responses.
     * Like sqlmap's automatic --string detection: finds text present in the true
     * response but absent from the false response.
     *
     * NOT hardcoded to any specific string — dynamically detects the best candidate
     * by diffing the two response bodies using multiple strategies:
     * 1. HTML visible text extraction (finds text between tags)
     * 2. Line-level diff (finds unique lines)
     * 3. Word-level diff (finds unique words)
     *
     * @param trueBody  response body when condition is true
     * @param falseBody response body when condition is false
     * @return the best distinguishing string, or null if none found
     */
    public String autoDetectTrueString(String trueBody, String falseBody) {
        if (trueBody == null || falseBody == null) return null;

        // Strategy 1: Find visible text between HTML tags unique to true response
        // This catches things like "Welcome back!", "Results found", "Logged in", etc.
        String best = null;
        Pattern textBetweenTags = Pattern.compile(">([^<]{3,})<");
        Matcher m = textBetweenTags.matcher(trueBody);
        while (m.find()) {
            String text = m.group(1).trim();
            if (text.length() < 3 || text.length() > 200) continue;
            if (text.matches("\\s+")) continue;  // Skip whitespace-only

            if (!falseBody.contains(text)) {
                // This visible text only exists in the true response
                if (best == null || (text.length() > best.length() && text.length() <= 80)) {
                    best = text;
                }
            }
        }
        if (best != null) return best;

        // Strategy 2: Line-level diff — find lines unique to true response
        String[] trueLines = trueBody.split("\\n");
        Set<String> falseLineSet = new HashSet<>(Arrays.asList(falseBody.split("\\n")));

        for (String line : trueLines) {
            String trimmed = line.trim();
            if (trimmed.length() < 4 || trimmed.length() > 500) continue;
            if (falseLineSet.contains(trimmed)) continue;

            // Strip HTML tags and get visible text
            String text = trimmed.replaceAll("<[^>]+>", "").trim();
            if (text.length() >= 4 && text.length() <= 100 && !falseBody.contains(text)) {
                if (best == null || text.length() > best.length()) {
                    best = text;
                }
            }
        }
        if (best != null) return best;

        // Strategy 3: Word-level diff — find unique meaningful words
        Set<String> trueWords = new LinkedHashSet<>(Arrays.asList(
                trueBody.replaceAll("<[^>]+>", " ").split("\\s+")));
        Set<String> falseWords = new HashSet<>(Arrays.asList(
                falseBody.replaceAll("<[^>]+>", " ").split("\\s+")));

        for (String word : trueWords) {
            if (word.length() >= 4 && !falseWords.contains(word)
                    && !word.matches("[\\d.]+") && !word.startsWith("\"")
                    && !word.matches("[a-f0-9]{16,}")) {  // Skip hex tokens
                return word;
            }
        }

        return null;
    }

    /** Fingerprint record for fast comparison */
    public record ResponseFingerprint(int contentLength, long lineCount, String normalizedContent) {}

    /** A dynamic region identified during calibration */
    private record DynamicRegion(int offset, int length) {}
}
