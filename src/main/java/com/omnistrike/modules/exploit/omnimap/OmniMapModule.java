package com.omnistrike.modules.exploit.omnimap;

import burp.api.montoya.MontoyaApi;
import burp.api.montoya.http.message.HttpRequestResponse;
import com.omnistrike.framework.ActiveScanExecutor;
import com.omnistrike.framework.DeduplicationStore;
import com.omnistrike.framework.FindingsStore;
import com.omnistrike.model.*;
import com.omnistrike.ui.modules.OmniMapPanel;

import java.util.Collections;
import java.util.List;

/**
 * OmniMap — a high-speed sqlmap variant built into OmniStrike.
 *
 * This module provides SQL injection EXPLOITATION (data extraction)
 * as a complement to the SmartSqliDetector which handles DETECTION.
 *
 * Once a parameter is confirmed injectable, the user right-clicks and selects
 * "Send to OmniMap" to open the configuration dialog, then the engine extracts
 * databases, tables, columns, and data using the fastest available technique.
 *
 * Key improvements over sqlmap:
 * - Parallel character extraction (5+ threads for blind)
 * - Adaptive bisection (common chars first → full ASCII fallback)
 * - Predictive string matching (common DB names tested first)
 * - Response fingerprint caching (skip redundant baselines)
 * - GROUP_CONCAT batching (all values in one request on MySQL)
 * - Integrated UI with real-time progress, tree view, request log
 *
 * When OmniMap is running, it pauses all other OmniStrike scan threads
 * to give it maximum priority and avoid interfering with timing-sensitive
 * exploitation techniques.
 */
public class OmniMapModule implements ScanModule {

    private MontoyaApi api;
    private DeduplicationStore dedup;
    private FindingsStore findingsStore;
    private OmniMapEngine engine;
    private OmniMapPanel panel;
    private ActiveScanExecutor scanExecutor; // reference to pause/resume other scans

    @Override
    public String getId() { return "omnimap-exploiter"; }

    @Override
    public String getName() { return "OmniMap Exploiter"; }

    @Override
    public String getDescription() {
        return "High-speed SQL injection exploitation engine — a sqlmap variant with parallel extraction, " +
                "adaptive bisection, and integrated Burp UI. Extracts databases, tables, columns, and data.";
    }

    @Override
    public ModuleCategory getCategory() { return ModuleCategory.INJECTION; }

    @Override
    public boolean isPassive() { return false; }

    /**
     * OmniMap does NOT process passive traffic — exploitation is triggered
     * exclusively via the right-click context menu "Send to OmniMap".
     */
    @Override
    public List<Finding> processHttpFlow(HttpRequestResponse requestResponse, MontoyaApi api) {
        return Collections.emptyList();
    }

    @Override
    public void initialize(MontoyaApi api, ModuleConfig config) {
        this.api = api;
        this.engine = new OmniMapEngine(api);
    }

    @Override
    public void destroy() {
        if (engine != null) {
            engine.stop();
        }
    }

    public void setDependencies(DeduplicationStore dedup, FindingsStore findingsStore) {
        this.dedup = dedup;
        this.findingsStore = findingsStore;
    }

    public void setScanExecutor(ActiveScanExecutor executor) {
        this.scanExecutor = executor;
    }

    public void setPanel(OmniMapPanel panel) {
        this.panel = panel;
    }

    public OmniMapPanel getPanel() {
        return panel;
    }

    /**
     * Start exploitation. Called from the context menu after config dialog.
     * Pauses other OmniStrike scans during execution for maximum priority.
     */
    public void exploit(HttpRequestResponse request, OmniMapConfig config) {
        if (api == null || engine == null) return;

        // Pause other scans for priority
        boolean wasPaused = false;
        if (scanExecutor != null) {
            scanExecutor.pause();
            wasPaused = true;
            api.logging().logToOutput("[OmniMap] Paused other OmniStrike scans for exploitation priority.");
        }

        final boolean needResume = wasPaused;

        // Create callback that bridges engine → panel
        OmniMapCallback panelCallback = createPanelCallback(request, config, needResume);

        // Start the engine
        engine.exploit(request, config, panelCallback);
    }

    /**
     * Stop the running exploitation.
     */
    public void stopExploit() {
        if (engine != null) {
            engine.stop();
        }
        // Resume other scans
        if (scanExecutor != null) {
            scanExecutor.resume();
            api.logging().logToOutput("[OmniMap] Resumed other OmniStrike scans.");
        }
    }

    /**
     * Create a callback that forwards engine events to the UI panel
     * and reports findings to FindingsStore.
     */
    private OmniMapCallback createPanelCallback(HttpRequestResponse request,
                                                 OmniMapConfig config, boolean needResume) {
        return new OmniMapCallback() {
            @Override
            public void onProgress(String status, int percent) {
                if (panel != null) panel.updateProgress(status, percent);
                api.logging().logToOutput("[OmniMap] " + status);
            }

            @Override
            public void onDbmsDetected(String dbms) {
                if (panel != null) panel.setDbms(dbms);
            }

            @Override
            public void onDatabasesFound(java.util.List<String> databases) {
                if (panel != null) panel.addDatabases(databases);

                // Report as finding
                findingsStore.addFinding(Finding.builder(
                        "omnimap-exploiter",
                        "SQL Injection — Databases Extracted",
                        Severity.CRITICAL,
                        Confidence.CERTAIN
                )
                        .description("OmniMap extracted " + databases.size() + " database(s): " +
                                String.join(", ", databases))
                        .url(request.request().url())
                        .parameter(config.getParameterName())
                        .evidence("Databases: " + String.join(", ", databases))
                        .remediation("Use parameterized queries / prepared statements. " +
                                "Never concatenate user input into SQL queries.")
                        .requestResponse(request)
                        .build());
            }

            @Override
            public void onTablesFound(String database, java.util.List<String> tables) {
                if (panel != null) panel.addTables(database, tables);

                findingsStore.addFinding(Finding.builder(
                        "omnimap-exploiter",
                        "SQL Injection — Tables Extracted from " + database,
                        Severity.CRITICAL,
                        Confidence.CERTAIN
                )
                        .description("OmniMap extracted " + tables.size() + " table(s) from " + database +
                                ": " + String.join(", ", tables))
                        .url(request.request().url())
                        .parameter(config.getParameterName())
                        .evidence("Tables in " + database + ": " + String.join(", ", tables))
                        .remediation("Use parameterized queries / prepared statements.")
                        .requestResponse(request)
                        .build());
            }

            @Override
            public void onColumnsFound(String database, String table, java.util.List<String> columns) {
                if (panel != null) panel.addColumns(database, table, columns);
            }

            @Override
            public void onRowExtracted(String database, String table,
                                        java.util.Map<String, String> row) {
                if (panel != null) panel.addRow(database, table, row);
            }

            @Override
            public void onRequestSent(HttpRequestResponse reqResp, String payload, String technique, long responseTimeMs) {
                if (panel != null) panel.addRequestLog(reqResp, payload, technique, responseTimeMs);
            }

            @Override
            public void onComplete(OmniMapResult result) {
                if (panel != null) panel.onComplete(result);
                api.logging().logToOutput("[OmniMap] Complete. " + result.getRequestCount() +
                        " requests in " + (result.getElapsedMs() / 1000) + "s");

                // Resume other scans
                if (needResume && scanExecutor != null) {
                    scanExecutor.resume();
                    api.logging().logToOutput("[OmniMap] Resumed other OmniStrike scans.");
                }
            }

            @Override
            public void onError(String message) {
                if (panel != null) panel.onError(message);
                api.logging().logToError("[OmniMap] " + message);

                // Resume other scans even on error
                if (needResume && scanExecutor != null) {
                    scanExecutor.resume();
                }
            }
        };
    }
}
